<!DOCTYPE html> 

<html>
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="myDEv.css" rel="stylesheet" type="text/css" />
  <script src="uni.js?rr={rndJS}"></script>
</head> 

<body> 
  <!-- myDev -->
  <div id="myDev">
    <div>
    <span id="myspan1"> </span>
    <span id="myspan2"> </span>
    <span id="myspan3"> </span>
    </div>
    <div>
      <span id="myspan"> </span>
      <span id="spanFLY"> |</span>
      <span id="mainTimeS"> </span>
    </div>
  </div>
  <div id="meritko">50% 512px</div>
<div id="myfps"></div>    
<!-- ebd myDev -->  

  <div id="racer">
    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>
    <div id="iblock">
      <canvas id="icanvas"> </canvas>
      <div id="isend"> </div>
      <span id="iscreen"><pre></pre></span>  
      <div id="ikeys">
        <div id="qwe" ></div>
        <div id="asd" ></div>
        <div id="zxc" ></div>
        <div id="ispace"></div>
        <span id="ireturn"></span>
        <span id="iback"></span>
     </div>
    </div>
    <div id="full-scr"></div>
  </div>

  <!-- // <script src="http://1gr.cz/js/uni/uni.js?rr={rndJS}"></script> -->

  <script src="stats.js"></script>

  <script>

(function(){
  var elem= document.getElementById('full-scr');
  elem.style.cssText = "width: 50px; height:50px; background:rgba(0,200,200,.4);position:absolute;left: 1000px; cursor:pointer;box-shadow: 0 0 10px 2px blue;  " 
  elem.onclick = function(){
    racer.webkitRequestFullScreen();
    canvas.style.cssText = "width:'100%';height:'100%';position:absolute"
  }


})();


//=========================================================================
// DOM - pomocky , doladit element

var Dom = {
  set:  function(id, html)               { element(id).innerHTML = html;                        },
  on:   function(ele, type, fn, capture) { element(ele).addEventListener(type, fn, capture);    },
  un:   function(ele, type, fn, capture) { element(ele).removeEventListener(type, fn, capture); },
  show: function(ele, type)              { element(ele).style.display = (type || 'block');      },
  blur: function(ev)                     { ev.target.blur();                                    },
}

//=========================================================================
// Math-pomocky

var Util = {
  timestamp:        function()                  { return new Date().getTime();                                    },
  limit:            function(value, min, max)   { return Math.max(min, Math.min(value, max));                     },
  accelerate:       function(v, accel, dt)      { return v + (accel * dt);                                        },
  exponentialFog:   function(distance, density) { return 1 / (Math.pow(Math.E, (distance * distance * density))); },
  toInt : function(obj, def){ if (obj !== null) { var x = parseInt(obj, 10); if (!isNaN(x)) return x; } return Util.toInt(def, 0); },

  easeIn:           function(a,b,percent)       { return a + (b-a)*Math.pow(percent,2);                           },
  easeOut:          function(a,b,percent)       { return a + (b-a)*(1-Math.pow(1-percent,2));                     },
  easeInOut:        function(a,b,percent)       { return a + (b-a)*((-Math.cos(percent*Math.PI)/2) + 0.5);        },
 
  increase:  function(start, increment, max) { // with looping
    var result = start + increment;
    while (result >= max)
      result -= max;
    while (result < 0)
      result += max;
    return result;
    }
  }

 




onload = function(){
   run_attr = {canvas: canvas, render: render, update: update, step: step}

    Game.run({
      canvas: canvas, 
      render: render, update: update,
      step: step,
      images: ["background.png", "jpghory.jpg", "vorota.png", "iphone.png"], 
      keys: [
        { keys: [KEY.LEFT ], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP   ], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN ], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.LEFT ], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP   ], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN ], mode: 'up',   action: function() { keySlower = false; } },

        { keys: [KEY.W ], mode: 'down', action: function() {  fly.up   = true;  } },
        { keys: [KEY.W ], mode: 'up',   action: function() {  fly.up   = false; } },
        { keys: [KEY.E ], mode: 'down', action: function() {  fly.down = true;  } },
        { keys: [KEY.E ], mode: 'up',   action: function() {  fly.down = false; } },


        { keys: [KEY[1],  KEY.A], mode: 'down',   action: function() { activeKey = -.8; } },
        { keys: [KEY[2],  KEY.S], mode: 'down',   action: function() { activeKey = -.4; } },
        { keys: [KEY[3],  KEY.D], mode: 'down',   action: function() { activeKey = 0; } },
        { keys: [KEY[4],  KEY.F], mode: 'down',   action: function() { activeKey = .4; } },
        { keys: [KEY[5],  KEY.G], mode: 'down',   action: function() { activeKey = .8; } },
        { keys: [KEY[1],  KEY.A], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[2],  KEY.S], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[3],  KEY.D], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[4],  KEY.F], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[5],  KEY.G], mode: 'up',   action: function() { activeKey = null; } }

      ],
      ready: function(images) {
        
        // for (var i = 0; i < images.length; i+=1) {
        //   imgElements.push(images[i]);
        // };
        imgElements.background = images[0];
        imgElements.sky = images[1];
        imgElements.brana = images[2];
        imgElements.mobile = images[3];
        
//         resetRoad();
        // /*test*/ segments[2].sprites.push({ source: brana, offset:  0  }); // rozmer = rozdelit puvodni rozmer na "rozmer"
        
      }
    });

}

/*fast =  function (time){
  var i = 20;
  var p10 = cameraDepth/5;
  var zrych = setInterval(function(){
    cameraDepth = cameraDepth- p10;
     p10 = cameraDepth/2;
    if (i) i--
    else { 
      clearInterval(zrych)
      var stop = setInterval(function(){
        p10 = cameraDepth*2;
        cameraDepth = cameraDepth+ p10;
        i++
        if (i == 20 ) clearInterval(stop) 
      },time)    
    }
  }, time*2);
};*/

//=========================================================================
// GAME LOOP helpers
//=========================================================================


// timeCounter = {};

// timeCounter.refreshTime =  

// a modified version of the game loop from my previous boulderdash game - see http://codeincomplete.com/posts/2011/10/25/javascript_boulderdash/#gameloop

var Game = {  
  timeCounter : 
    (function(){
      var last = Util.timestamp();
      var distanceStart, distance;
      var rozdil
      var totalTime = 0;
      
      return { 
        distance2sek : function(){
          if (distanceStart == undefined) {
            distanceStart = totalTime;
            position = 0;
            console.info('zacatek mereni')
          } else {
            rozdil = (totalTime - distanceStart);
            if (( rozdil >= 2.5)  && (rozdil <= 2.6)) {
              distance = position;
              this.distance2sek = distance;
            }
          }
        },
        totalTime : 0,
        refreshTime : function (now){
          totalTime = +((now - last) / 1000).toFixed(1);
          this.totalTime = totalTime;
          mainTimeS.innerHTML = '  Time:<b>' +  this.totalTime + ' sek </b>'; 
        }
      }

    })
  (),

  scoreCounter : [],

  run: function(options) {
    Game.loadImages(options.images, function(images) {

      options.ready(images); 
      Game.mobil()
      Game.setKeyListener(options.keys);

      var canvas = options.canvas,   
          update = options.update,   
          render = options.render,   
          step   = options.step,     
          stats  = new Stats('myfps'), // tady je nutne ukazat ID Elementu kam se vlozi grafik fps

          now    = null,
          last   = Util.timestamp(),
          dt     = 0,
          gdt    = 0;

      /* Hlavni smysl je takovy, aby   
      /* Основная идея состоит в том, чтобы накопить наш dt пока это не больше, чем наше желаемое зафиксировало timestep, звонить update с фиксированным timestep, и переносят остаток, чтобы накопиться в следующий раз. */
      var frame = function() {
        now = Util.timestamp();
        Game.timeCounter.refreshTime(now);
        dt  = Math.min(1, (now - last) / 1000); // vzdy 1 sek
        gdt = gdt + dt;
         
        while (gdt > step) {   
          gdt = gdt - step;
          update(step);
        }
        render();
        stats.update();
        last = now;
        requestAnimationFrame(frame, canvas);
      }
      frame(); 
    });
  },




  //---------------------------------------------------------------------------

  loadImages: function(names, callback) { // load multiple images and callback when ALL images have loaded
    var result = [];
    var count  = names.length;

    var onload = function() {
      if (--count == 0)
        callback(result);
    };

    for(var n = 0 ; n < names.length ; n++) {
      var name = names[n];
      result[n] = document.createElement('img');
      Dom.on(result[n], 'load', onload);
      result[n].src = "images/" + name ;
      result[n].alt = name;
    };
  },

  //---------------------------------------------------------------------------

  setKeyListener: function(keys) {

    var onkey = function(keyCode, mode) {
      var n, k;
      for(n = 0 ; n < keys.length ; n++) {
        k = keys[n];
        k.mode = k.mode || 'up';
        if ((k.key == keyCode) || (k.keys && (k.keys.indexOf(keyCode) >= 0))) {
          if (k.mode == mode) {
            k.action.call();
            return true;
          }
        }
      }
    };

    Dom.on(document, 'keydown', function(ev) { onkey(ev.keyCode, 'down')? ev.preventDefault(): null;  } );
    Dom.on(document, 'keyup',   function(ev) { onkey(ev.keyCode, 'up')?   ev.preventDefault(): null;  } );
  },



  mobil : function(){
    var iCanvas = document.getElementById('icanvas'),
        ictx    = iCanvas.getContext('2d'),
        img    = imgElements.mobile,
        width  = iCanvas.width  = img.width*0.7,
        height = iCanvas.height = img.height*0.7,
        allKeys =  document.getElementById('ikeys'),
//         sprava = document.getElementById('isprava'),
        iSend  = document.getElementById('isend');
    
    var CONST_KEYS = {
          qwe : ["q", "w","e","r","t","y","u","i","o","p"],
          asd : ["a","s","d","f","g","h","j","k","l"],
          zxc : ["z","x","c","v","b","n","m"],
          ispace  : [" "],
          ireturn : ["\n"],
          iback   : ['BS']
        };

    ictx.globalAlpha = 0.85;
    ictx.drawImage(img,0,0,width, height);

    var pocet, fragment, table, td, row;

    for (row in CONST_KEYS){
      pocet = CONST_KEYS[row].length;
      fragment = document.createDocumentFragment();
      table = document.createElement('table');
      tr = document.createElement('tr');
      table.appendChild(tr);
      for (var i = 0; i < pocet; i++) {
        td = document.createElement('td');
        td.innerHTML = CONST_KEYS[row][i];
        tr.appendChild(td);
      };
      fragment.appendChild(table);
      document.getElementById(row).appendChild(fragment);
    }

    allKeys.onclick = function(event){
      var sprava = document.getElementById('iscreen').getElementsByTagName('pre')[0],
          iscreen = sprava.parentNode,
          elem = event.target,
          letter;
      if (elem.tagName != 'TD') return;
      letter = elem.innerHTML;    
      if (letter ==="BS") { 
        sprava.innerHTML = sprava.innerHTML.substring(0, sprava.innerHTML.length-1)
      } else {
        sprava.innerHTML = sprava.innerHTML + letter 
      }
      iscreen.scrollTop = iscreen.scrollHeight - iscreen.clientHeight;
    }; // allKeys.onClick

    iSend.onclick = function(){
      var pre = document.getElementById('iscreen').getElementsByTagName('pre')[0];
      pre.innerHTML = '<b> SPrava byla Odeslana !!! </b>'   
      setTimeout(function(){ pre.innerHTML = ''}, 2000);
    }
  }, //end Mobil






}  // Game



//=========================================================================
// canvas rendering helpers
//=========================================================================

var Render = {

  polygon: function(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
    /* dalnice */
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    ctx.fill();
  },

  //---------------------------------------------------------------------------

  segment: function(ctx, width, lanes, x1, y1, w1, x2, y2, w2, fog, color) {

    var r1 = Render.rumbleWidth(w1, lanes);
    var r2 = Render.rumbleWidth(w2, lanes);
    var l1 = Render.laneMarkerWidth(w1, lanes);
    var l2 = Render.laneMarkerWidth(w2, lanes);
    var    lanew1, lanew2, lanex1, lanex2, lane;
    
    ctx.fillStyle = color.grass;
    ctx.fillRect(0, y2, width, y1 - y2);
    
    Render.polygon(ctx, x1-w1-r1, y1, x1-w1, y1, x2-w2, y2, x2-w2-r2, y2, color.rumble);  // leva bordura
    Render.polygon(ctx, x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);    // prava bordura
    Render.polygon(ctx, x1-w1,    y1, x1+w1, y1, x2+w2, y2, x2-w2,    y2, color.road);

    // BILE PRUHY UPROSTRED DALNICE
    if (color.lane) {
      lanew1 = w1*2/lanes;
      lanew2 = w2*2/lanes;
      lanex1 = x1 - w1 + lanew1;
      lanex2 = x2 - w2 + lanew2;
      for(lane = 1 ; lane < lanes ; lanex1 += lanew1, lanex2 += lanew2, lane++)
        Render.polygon(ctx, lanex1 - l1/2, y1, lanex1 + l1/2, y1, lanex2 + l2/2, y2, lanex2 - l2/2, y2, color.lane);
    }
    
    Render.fog(ctx, 0, y1, width, y2-y1, fog);
  },

  //---------------------------------------------------------------------------
 
  jezdiciImg : function(option){
     var  img   = option.img,
          destX = option.destX,
          destY = option.destY,
          scale = option.scale,
          offsetX = option.offsetX||0,
          offsetY = option.offsetY||1,
          rozmer  = option.rozmer||1,
          gate    = option.gate;

      var destW  = (img.width  * scale * width/rozmer) * ((1/img.width) * roadWidth);
      var destH  = (img.height * scale * width) * ((1/img.width) * roadWidth);
       
      destX = destX - (  destW /2 ); 
      destY = destY - (  destH * offsetY ); 
      // ctx.drawImage(img, // 0, sprite.y, img.w, img.h ,destX, destY , destW, destH );
      ctx.drawImage(img, destX, destY , destW, destH );

      ctx.setLineDash([]);
      ctx.strokeStyle= '#f00';
      ctx.lineWidth = 2;
      ctx.strokeRect(destX, destY , destW, destH);
      if (gate == undefined) return
      Render.spravnyPruh(destX, destY , destW, destH, gate);
  },

  spravnyPruh : function(destX, destY , destW, destH, gate){ 
        ctx.strokeStyle= '#ff0';
        ctx.lineWidth = 3
        ctx.setLineDash([8, 10]);
        var linieW = destW/lanes,  sloub = linieW * .1 ; 
        ctx.strokeRect(destX + linieW*gate + sloub*gate, destY +ctx.lineWidth , linieW- sloub*gate, destH)
        ctx.strokeStyle= '#f00';
  },

  //---------------------------------------------------------------------------

  fog: function(ctx, x, y, width, height, fog) {
    if (fog < 1) {
      ctx.globalAlpha = (1-fog);
      ctx.fillStyle = COLORS.FOG;
      ctx.fillRect(x, y, width, height);
      ctx.globalAlpha = 1;
    }
  },

  rumbleWidth:     function(projectedRoadWidth, lanes) { return projectedRoadWidth/Math.max(6,  2*lanes); },
  laneMarkerWidth: function(projectedRoadWidth, lanes) { return projectedRoadWidth/Math.max(32, 8*lanes); }

}


// for (var i = 0; i < arr.length; i++) {
//   arr[i]
// };



  </script>























  <script>
//=============================================================================
// RACING GAME CONSTANTS
//=============================================================================

          var KEY = {
              LEFT:  37,  /*A:     65,*/
              UP:    38,  /*D:     68,*/
              RIGHT: 39,  /*S:     83,*/
              DOWN:  40,  W:     87,  E:69,
              A: 65, S: 83, D: 68, F: 70, G: 71,
              1: 49, 2: 50, 3: 51, 4: 52, 5: 53
            };

          var COLORS = {
              SKY:  '#72D7EE',
              TREE: '#005108',
              FOG: 'rgba(250,0,0,1)',  // '#2a4c60',
              LIGHT:  { road: '#5B6B6B', grass: '#00eaea', rumble: '#555', lane: '#ACCCCC'  },
              DARK:   { road: '#696969', grass: '#026767', rumble: '#BBB'                   },
              START:  { road: '#f00',   grass: 'white',   rumble: 'white'                  },
              MY:     { road: '#40cc40',   grass: 'white',   rumble: 'white'                  },
              FINISH: { road: 'black',   grass: 'black',   rumble: 'black'                  }
            };
  /* Canvas a IMGs */
          var fps           = 60;                      // how many 'update' frames per second
          var step          = 1/fps;                   // how long is each frame (in seconds)
          var segments      = [];                      // array of road segments
          var canvas        = element('canvas');       // our canvas...
          var ctx           = canvas.getContext('2d');
          var width         = 1024;                    // logical canvas width
          var height        = 768;                     // logical canvas height
              canvas.width  = width
              canvas.height = height

          var imgElements  = {}    
          var sprites       = null;                    // our spritesheet (loaded below)
          /*var resolution    = null;     // pokud potrebujem ruzne verze podle vykonosti , t.j.  resolution    = height/(height*500);
          */    

  /* DALNICE a Camera */    
          var roadWidth     = 2000;                    // actually half the roads width, easier math if the road spans from -
          var segmentLength = 200;                     // length of a single segment
          var rumbleLength  = 3;                       // number of segments per red/white rumble strip // strip = полосa
          var trackLength   = null;                    // cela dalnice, t.j. 1 kolo.  z length of entire track (computed) track = trassa
          var lanes         = 5;                       // number of lanes
          var fieldOfView   = 100;                     // angle (degrees) for field of view
          var cameraHeight  = 300;                    // z height of camera.;from screen (computed)
              cameraDepth  = 1 / Math.tan((fieldOfView/2) * Math.PI/180);

          var drawDistance  = 300;                     // number of segments to draw
          var fogDensity    = 0;                       // exponential fog density
          var playerX       = 0;                       
                                                   
          var playerZ       = null;                    // player relative z distance from camera (computed)
              playerZ       = (cameraHeight * cameraDepth);

  /* Rizeni */
          var position      = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
          var speed         = 10000;                       // current speed
          var maxSpeed      = 10000//segmentLength/step ;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)  // garance min 1 segment v 1 snimek

          var accel         =  maxSpeed/5;             // acceleration rate - tuned until it 'felt' right ..ускорения - 
          var breaking      = -maxSpeed;               // deceleration rate when braking   // замедление 

          var keyLeft       = false;
          var keyRight      = false;
          var keyFaster     = false;
          var keySlower     = false;

          var activeKey      = null //vypocetava se4
          var key1           = false,
              key2           = false,
              key3           = false,
              key4           = false,
              key5           = false;
          var zataci = false;
          var pruh   = null;
          var zrychleni = 1;

          var fly= {};
              fly.down = false;
              fly.up   = false;

              vyskaY = 0
            

         //    /*dev*/ myspan.innerHTML = 'zrychl: <b> O_0</b>';
         //    /*dev*/ myspan3.innerHTML = 'dx=<b> O_o</b> |   PlayerX= <b> XxX  </b>';



    //=========================================================================
    // BUILD ROAD GEOMETRY\
    //=========================================================================



      function addHill(num, height) {
        num    = num    || 25;
        height = height || 20;
        addRoad(num, num, num, 0, height);
      }

    function addLowRollingHills(num, height) {
      num    = num    || 25;
      height = height || 20;
      addRoad(num, num, num,  0,  height/2);
      addRoad(num, num, num,  0, -height);
      addRoad(num, num, num,  0,  height);
      addRoad(num, num, num,  0,  0);
      addRoad(num, num, num,  0,  height/2);
      addRoad(num, num, num,  0,  0);
    }






  function addRoad(enter, hold, leave, curve, y) {
      var startY   = lastY();
      var endY     = startY + (Util.toInt(y, 0) * segmentLength);
      var n, total = enter + hold + leave;
      for(n = 0 ; n < enter ; n++)
        addSegment(Util.easeIn(0, curve, n/enter), Util.easeInOut(startY, endY, n/total));
      for(n = 0 ; n < hold  ; n++)
        addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));
      for(n = 0 ; n < leave ; n++)
        addSegment(Util.easeInOut(curve, 0, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));

      
    }

     function lastY() {
        return (segments.length == 0) ? 0 : segments[segments.length-1].p2.world.y;
      }

    function addSegment(y) {
      /* zavolat po   Starter.resize(funkce) */
      segments = [];
      // чтоб не было стробного эффекта ..........
      for(var n = 0 ; n < 500 ; n++) {
        segments.push({
           index: n,
           p1: { world: { y: lastY(),   z:  n   *segmentLength,   }, camera: {}, screen: {} },
           p2: { world: { y: y,         z: (n+1)*segmentLength,   }, camera: {}, screen: {} },
           sprites : [],
           color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
        });
      }
    }
 
        

    function addDownhillToEnd(num) {
      num = num || 200;
      addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY()/segmentLength);
    }



        
    function addLowRollingHills(num, height) {
      num    = num    || 25;
      height = height || 20;
      addRoad(num, num, num,  0,  height/2);
      addRoad(num, num, num,  0, -height);
      addRoad(num, num, num,  0,  height);
      addRoad(num, num, num,  0,  0);
      addRoad(num, num, num,  0,  height/2);
      addRoad(num, num, num,  0,  0);
    }

    function addDownhillToEnd(num) {
      num = num || 200;
      addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY()/segmentLength);
    }

  


    function addStraight(num) {
      num = num || ROAD.LENGTH.MEDIUM;
      addRoad(num, num, num, 0, 0);
    }


    var ROAD = {
      LENGTH: { NONE: 0, SHORT:  25, MEDIUM:  50, LONG:  100 },
      HILL:   { NONE: 0, LOW:    20, MEDIUM:  40, HIGH:   60 },
      CURVE:  { NONE: 0, EASY:    2, MEDIUM:   4, HARD:    6 }
    };







      // resetRoad =  function () {
      segments = [];

      addStraight(ROAD.LENGTH.SHORT/2);
      addHill(ROAD.LENGTH.SHORT, ROAD.HILL.LOW);
      addLowRollingHills();
// //       addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
      addLowRollingHills();
//       addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
      addStraight();
//       addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
      addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH);
//       addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
      addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);
      addStraight();
      addDownhillToEnd();

      segments[findSegment(playerZ).index + 2].color = COLORS.START;
      segments[findSegment(playerZ).index + 3].color = COLORS.START;
      for(var n = 0 ; n < rumbleLength ; n++)
        segments[segments.length-1-n].color       = COLORS.FINISH;

      trackLength = segments.length * segmentLength;
    // }
      // segments[199].sprites.push({ source: imgElements.brana, offset: -1, gate: 1}); 
      // segments[299].sprites.push({ source: imgElements.brana, offset: 0, gate: 1}); 
    /*  segments[399].sprites.push({ source: imgElements.brana, offset: 0, gate: 1}); 
      segment =  findSegment(79800)
            Game.scoreCounter.push({index: segment.index, casEnd: null, gate:0, playerX:null })
*/
      segments[findSegment(playerZ).index + 2].color = COLORS.START;
      segments[1].color = COLORS.MY;
      trackLength = segments.length * segmentLength;
    




    /* docasna f()*/
/*    function addSprite(n, sprite, offset) {
      segments[n].sprites.push({ source: sprite, offset: offset });
    };
*/

    function findSegment(z) {
      return segments[Math.floor(z/segmentLength) % segments.length];
    };


    function vypocetProjekce (p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth, dvojka) {
      /*  cameraX : (playerX * roadWidth), 
          cameraY : cameraHeight,
          cameraZ : position - (segment.looped ? trackLength : 0),
      */
      p.camera.x     = (p.world.x || 0) - cameraX;
      p.camera.y     = (p.world.y || 0) - cameraY;
      p.camera.z     = (p.world.z || 0) - cameraZ;
      p.screen.scale = cameraDepth/p.camera.z;
      p.screen.x     = Math.round((width/2)  + (p.screen.scale * p.camera.x  * width/2));
      p.screen.y     = Math.round((height/2) - (p.screen.scale * p.camera.y  * height/2));
      p.screen.w     = Math.round(             (p.screen.scale * roadWidth   * width/2));
    };


    //=========================================================================
    //        U P D A T E      -----        U P D A T E
    //=========================================================================

    function update(dt) {
      position = Util.increase(position, dt * speed, trackLength);
      // at top speed, should be able to cross from left to right (-1 to 1) in 1 secon d
      var dx = +(dt * (speed/maxSpeed)).toFixed(3) ;    
      var len =  Game.scoreCounter.length,
          casEnd;
      
      var baseSegment = findSegment(position);
      if (baseSegment.sprites.length) {
        /* projizdi branu */ 
        Game.scoreCounter[len-1].playerX = +(((playerX + .8)/.4).toFixed(2)); // playerX;
       //console.info('Projel po gatu=',((playerX + .8)/.4).toFixed(2), ' a musel po', baseSegment.sprites[0].gate);
      }


      if (accelerate) accelerate()
      else run(position)


      if (len) casEnd =  Game.scoreCounter[len-1].casEnd;

      if ((activeKey !== null) && (casEnd === null))  {
         Game.scoreCounter[len-1].casEnd = Game.timeCounter.totalTime - Game.scoreCounter[len-1].casBegin;
      }
   
      if ((activeKey !== null) || (zataci)) changeLanes(dx);   /* zmena celeho pruhu  */

      doscanaFunc({ dt:dt, dx:dx }); /* rucni zmena pruhu  DEV */

    }


//=========================================================================


    function run(position){
      if (Game.timeCounter.totalTime % 5 == 0) {
        //pridejBranu(position, Game.timeCounter.totalTime);
      } ;
    };

//=========================================================================

  
  var pridejBranu = (function(position, time){
    var lastTime = 0;
    var gate = null, indexForBrana;
    var rand = Math.floor(Math.random()*5);
    
    return function(position,time){
      if (lastTime === time) return;
      lastTime = time;
      indexForBrana = findSegment(position + Game.timeCounter.distance2sek).index;   
      while (gate == rand){
        rand = Math.floor(Math.random()*5);
      }
      gate = rand;
      var segment = segments[indexForBrana];
      segment.sprites.push({ source: imgElements.brana, offset: 0, gate: gate }); 

      Game.scoreCounter.push({index: segment.index, casEnd: null, gate:gate, playerX:null })

      setTimeout(function(){
        segment.sprites = [];
      }, 10000);
    }
  })();


//=========================================================================

    function accelerate(){
      /* nejprve zvetsime rychlost na maximalni, pak zmerime kolik projede za 2.5 sek
         a ulozim do vzdalenost2sek pak udelame reset dalnice a smazeme func accelerate */
      if ( speed  < maxSpeed) {
        speed += 32 //Math.floor(speed/100);
      } else if ( typeof(Game.timeCounter.distance2sek) == 'function') {
        Game.timeCounter.distance2sek();
      } else {
        // addSegment();
        accelerate = null;
      };
    };

//=========================================================================

    function changeLanes(dx){
        if  (activeKey  !== null) {
          /* pokud v dobe zataceni, se vyberou jiny pruh, tak prepocitat zrychleni */
          if (pruh !== null && (pruh !== activeKey)) zataci = false;
          pruh =  activeKey;
        }
        if (!zataci) zrychleni = +Math.abs((playerX - activeKey)/0.4/2).toFixed(2);
        
        if (playerX !=  pruh ) {
            zataci = true;
            dx = +(dx * (zrychleni)).toFixed(7);
            playerX =  +(playerX + ((pruh - playerX) > 0 ? dx : 0-dx)).toFixed(3)
            var rozdil = +(playerX - pruh ).toFixed(2);
            if ((rozdil >= -0.01) && (rozdil <= 0.01 )) playerX = pruh;
          } else {
            zataci = false;
            zrychleni = 1;
            pruh = null;
        };
    };


    //=========================================================================
    //                  R E N D E R    -----    R E N D E R   
    //=========================================================================

    var render =  function() {
            
      var baseSegment = findSegment(position);
      var maxy     = height;

      /* render background*/
      ctx.clearRect(0, 0, width, height);4
      ctx.drawImage(imgElements.sky,0,0, width, (height/2) +15); //background
      var n, segment;


      /* render objekty na dalnice */
     for(n = (drawDistance-1) ; n > 0 ; n--) {
      segment        = segments[(baseSegment.index + n) % segments.length];
        if (segment.sprites !== undefined) {
          for(var i = 0 ; i < segment.sprites.length ; i++) {
            var spriteSOURCE = segment.sprites[0].source;  
            var sprite      = segment.sprites[i];
            var gate        = sprite.gate
            spriteScale = segment.p1.screen.scale;
            spriteX     = segment.p1.screen.x + (spriteScale *(sprite.offset||0) *  roadWidth * width/2);
            spriteY     = segment.p1.screen.y;


            Render.jezdiciImg({ 
                img    : spriteSOURCE,
                scale  : spriteScale,
                destX  : spriteX,
                destY  : spriteY,
                rozmer : sprite.rozmer, 
                offsetX: sprite.offset,
                gate: gate
            });
          }

        }
      };



      /*render road */
      for(n = 0 ; n < drawDistance ; n++) {
        segment        = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n/drawDistance, fogDensity);
        vypocetProjekce(segment.p1, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        vypocetProjekce(segment.p2, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth, true);
        if (segment.p1.camera.z <= cameraDepth)  continue; // behind us
        // if   (segment.p2.screen.y >= maxy) // continue;
           


        Render.segment(ctx, width, lanes,
                       segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.w,
                       segment.p2.screen.x, segment.p2.screen.y, segment.p2.screen.w,
                       segment.fog, segment.color);
        maxy = segment.p2.screen.y;
      };//for



      last = Util.timestamp();
    } ; // KONEC RENDER


  </script>
  <script src="delete.js"></script>
</body> 

