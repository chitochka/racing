<!DOCTYPE html> 

<html>
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="myDEv.css" rel="stylesheet" type="text/css" />
  <script src="uni.js?rr={rndJS}"></script>
</head> 

<body> 
  <!-- myDev -->
  <div id="myDev">
    <div>
    <span id="myspan1"> </span>
    <span id="myspan2"> </span>
    <span id="myspan3"> </span>
    </div>
    <div>
      <span id="myspan"> </span>
      <span id="spanFLY"> |</span>
      <span id="mainTimeS"> </span>
    </div>
  </div>
  <div id="meritko">50% 512px</div>
<div id="myfps"></div>    
<!-- ebd myDev -->  

  <div id="racer">
    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>
    <!-- dev DEV   DEV    DEV   -------------------------------------------------------------------------- -->
              <div id="score-online" > P.S. shova je zobrazena vzdy posledny spravy</div>
              <div id="devbuttons"> 
                <input type="button" id="devmobil" value="Mobile" onclick="Game.mobil.toggle()" >
                <input type="button" id="devstop" value="Stop" onclick="if (speed){speed=0} else speed=10000 ">
                <input type="button" id="devnewsms" value="New SMS" onclick="Game.mobil.newSMS()">
              </div>
    <!-- -------------------------------------------------------------------------------------------- -->
    <div id="icon-mobil" class="">✉</div>
    <div id="iblock">
      <canvas id="icanvas"> </canvas>
      <span id="iread"> READ</span>
      <span id="isend"> SEND </span>
      <span id="devOdpoved"> ... </span>
      <span id="insms"><pre>MÁTE NOVOU NEPREČTENOU SPRÁVU </pre></span>
      <span id="outsms"><pre></pre></span>  
      <div id="ikeys">
        <div id="qwe" ></div>
        <div id="asd" ></div>
        <div id="zxc" ></div>
        <div id="ispace"></div>
        <span id="ireturn"></span>
        <span id="iback"></span>
     </div>
    </div>
    <div id="full-scr">Full_Scr</div>
  </div>
  <!-- // <script src="http://1gr.cz/js/uni/uni.js?rr={rndJS}"></script> -->

  <script src="stats.js"></script>

  <script>
/*(function(){
  function score(){
    wrap.className = wrap.className ? '' : 'showed';
    if (!wrap.className) return
    var table = wrap.getElementsByTagName('table')[0];
    var items = Game.timer.score, item;

    for (var i=0; i<items.length; i++){
      item = items[i];
      var row = table.insertRow(i+1);
      var cell1 = row.insertCell(0);
      var cell2 = row.insertCell(1);
      var cell3 = row.insertCell(2);
      var cell4 = row.insertCell(3);
      cell1.innerHTML = i+1;
      cell2.innerHTML = item.time;
      cell3.innerHTML = item.projel;
      cell4.innerHTML = item.smskuje;
    };
  };

  var wrap = document.getElementById('score');
  var button = document.getElementById('scoreBtn');
  button.onclick = score
})();*/


(function(){
  function toggleFullScreen() {
        if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement) {  
          if (document.documentElement.requestFullscreen) {             document.documentElement.requestFullscreen();
          } else if (document.documentElement.mozRequestFullScreen) {   document.documentElement.mozRequestFullScreen();
          } else if (document.documentElement.webkitRequestFullscreen){ document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); 
        }
        } else {
          if (document.cancelFullScreen) {              document.cancelFullScreen();
          } else if (document.mozCancelFullScreen) {    document.mozCancelFullScreen();
          } else if (document.webkitCancelFullScreen) { document.webkitCancelFullScreen();
          }
        }
  };
  document.addEventListener("keydown", function(e) {
    if (e.keyCode == 13) toggleFullScreen();
  }, false);
  document.getElementById('full-scr').onclick = function(){ toggleFullScreen(); resetRoad(); }
})();


//=========================================================================
// DOM - pomocky , doladit element

var Dom = {
  set:  function(id, html)               { element(id).innerHTML = html;                        },
  on:   function(ele, type, fn, capture) { element(ele).addEventListener(type, fn, capture);    },
  un:   function(ele, type, fn, capture) { element(ele).removeEventListener(type, fn, capture); },
  show: function(ele, type)              { element(ele).style.display = (type || 'block');      },
  blur: function(ev)                     { ev.target.blur();                                    },
}

//=========================================================================
// Math-pomocky
 
var Util = {

  timestamp:        function()                  { return new Date().getTime();                                    },
  toInt:            function(obj, def)          { if (obj !== null) { var x = parseInt(obj, 10); if (!isNaN(x)) return x; } return Util.toInt(def, 0); },
  toFloat:          function(obj, def)          { if (obj !== null) { var x = parseFloat(obj);   if (!isNaN(x)) return x; } return Util.toFloat(def, 0.0); },
  limit:            function(value, min, max)   { return Math.max(min, Math.min(value, max));                     },
  randomInt:        function(min, max)          { return Math.round(Util.interpolate(min, max, Math.random()));   },
  randomChoice:     function(options)           { return options[Util.randomInt(0, options.length-1)];            },
  percentRemaining: function(n, total)          { return (n%total)/total;                                         },
  accelerate:       function(v, accel, dt)      { return v + (accel * dt);                                        },
  interpolate:      function(a,b,percent)       { return a + (b-a)*percent                                        },
  easeIn:           function(a,b,percent)       { return a + (b-a)*Math.pow(percent,2);                           },
  easeOut:          function(a,b,percent)       { return a + (b-a)*(1-Math.pow(1-percent,2));                     },
  easeInOut:        function(a,b,percent)       { return a + (b-a)*((-Math.cos(percent*Math.PI)/2) + 0.5);        },
  exponentialFog:   function(distance, density) { return 1 / (Math.pow(Math.E, (distance * distance * density))); },
  increase:  function(start, increment, max) { // with looping
    var result = start + increment;
    while (result >= max)
      result -= max;
    while (result < 0)
      result += max;
    return result;
  },
  rasstoyanieLevenstejna:        function (s1, s2, costs) {
    function preklep(s1,s2){
        for (var i = 0; i < l1; i++) {
          if (s1[i] === s2[i] ) continue;
          if  ((s1[i]===s2[i+1])  && ( s1[i+1]===s2[i]) ) { 
            if  ((s1.substring(0,i)===s2.substring(0,i)) && (s1.substring(i+2)===s2.substring(i+2))    ) {return true}
          };
        };
        return false;
    };
    var i, j, l1, l2, flip, ch, chl, ii, ii2, cost, cutHalf, l1 = s1.length, l2 = s2.length;
    s1 = s1.toLocaleLowerCase(); s2 = s2.toLocaleLowerCase();

    costs = costs || {};
    var cr = costs.replace || 1;
    var cri = costs.replaceCase || costs.replace || 1;
    var ci = costs.insert || 1;
    var cd = costs.remove || 1;
    cutHalf = flip = Math.max(l1, l2);
    var minCost = Math.min(cd, ci, cr);
    var minD = Math.max(minCost, (l1 - l2) * cd);
    var minI = Math.max(minCost, (l2 - l1) * ci);
    var buf = new Array((cutHalf * 2) - 1);

    for (i = 0; i <= l2; ++i) buf[i] = i * minD;
    for (i = 0; i < l1; ++i, flip = cutHalf - flip) {
      ch = s1[i];
      chl = ch.toLowerCase();
      buf[flip] = (i + 1) * minI;
      ii = flip;
      ii2 = cutHalf - flip;
      for (j = 0; j < l2; ++j, ++ii, ++ii2) {
        cost = (ch === s2[j] ? 0 : (chl === s2[j].toLowerCase()) ? cri : cr);
        buf[ii + 1] = Math.min(buf[ii2 + 1] + cd, buf[ii] + ci, buf[ii2] + cost);
      };
    };
    var rozdil = buf[l2 + cutHalf - flip];
    if (rozdil > 2) return false
    else if (rozdil == 2) return preklep(s1,s2)
    else return true;
  }
}



onload = function(){
   run_attr = {canvas: canvas, render: render, update: update, step: step}

    Game.run({
      canvas: canvas, 
      render: render, update: update,
      step: step,
      images: ["background.png", "sky.jpg", "brana.png", "iphone.png","red.jpg", "green.jpg", "start.png"], 
      keys: [
        { keys: [KEY.LEFT ], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP   ], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN ], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.LEFT ], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP   ], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN ], mode: 'up',   action: function() { keySlower = false; } },

        { keys: [KEY.W ], mode: 'down', action: function() {  fly.up   = true;  } },
        { keys: [KEY.W ], mode: 'up',   action: function() {  fly.up   = false; } },
        { keys: [KEY.E ], mode: 'down', action: function() {  fly.down = true;  } },
        { keys: [KEY.E ], mode: 'up',   action: function() {  fly.down = false; } },


        { keys: [KEY[1],  KEY.A], mode: 'down',   action: function() { activeKey = -.8; } },
        { keys: [KEY[2],  KEY.S], mode: 'down',   action: function() { activeKey = -.4; } },
        { keys: [KEY[3],  KEY.D], mode: 'down',   action: function() { activeKey = 0; } },
        { keys: [KEY[4],  KEY.F], mode: 'down',   action: function() { activeKey = .4; } },
        { keys: [KEY[5],  KEY.G], mode: 'down',   action: function() { activeKey = .8; } },
        { keys: [KEY[1],  KEY.A], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[2],  KEY.S], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[3],  KEY.D], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[4],  KEY.F], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[5],  KEY.G], mode: 'up',   action: function() { activeKey = null; } }

      ],
      ready: function(images) {
        var name, arrImg = {};
        for (var i = 0; i < images.length; i++) {
          name = images[i].alt.slice(0, -4).toLowerCase();
          arrImg[name] = images[i]
        };

        // Game.mobil.toggle()
        
        segments[130].sprites.push({ source: arrImg.start, offset: 0 }); 
        setTimeout(function(){segments[130].sprites = []},6000)

        segments[130].color = COLORS.START;
        segments[128].color = COLORS.START;
        segments[129].color = COLORS.START;
        segments[80].color = {road: "#cc0"};
        segments[77].color = {road: "#cc0"};
        segments[38].color = {road:"#c00"};
        segments[40].color = {road:"#c00"};
        segments[42].color = {road:"#c00"};

        return arrImg; 
      }
    });
};



//=========================================================================
//                                G A M E 
//=========================================================================

var Game = {  
  run: function(options) {
    Game.loadImages(options.images, function(images) {

      Game.loadImages = options.ready(images); 
      pridejBranu(PRVNI_BRANY)
      var mobilnik = Game.mobil.init();

      Game.setKeyListener(options.keys);

      var canvas = options.canvas,   
          update = options.update,   
          render = options.render,   
          step   = options.step,     
          stats  = new Stats('myfps'), // tady je nutne ukazat ID Elementu kam se vlozi grafik fps

          now    = null,
          last   = Util.timestamp(),
          dt     = 0,
          gdt    = 0;

      /* Hlavni smysl je takovy, aby   
      /* Основная идея состоит в том, чтобы накопить наш dt пока это не больше, чем наше желаемое зафиксировало timestep, звонить update с фиксированным timestep, и переносят остаток, чтобы накопиться в следующий раз. */
      var frame = function() {
        now = Util.timestamp();
        
        dt  = Math.min(1, (now - last) / 1000); // vzdy 1 sek
        gdt = gdt + dt;
         
        while (gdt > step) {   
          gdt = gdt - step;
          update(step);
        }
        render();
        stats.update();
        last = now;
        mereniCasu(now) /* dev */
        requestAnimationFrame(frame, canvas);
      }
      frame(); 
    });
  },




  //---------------------------------------------------------------------------

  loadImages: function(names, callback) { // load multiple images and callback when ALL images have loaded
    var result = [];
    var count  = names.length;

    var onload = function() {
      if (--count == 0) {
        
        resetRoad()
        callback(result);    
      }
    };

    for(var n = 0 ; n < names.length ; n++) {
      var name = names[n];
      result[n] = document.createElement('img');
      Dom.on(result[n], 'load', onload);
      result[n].src = "images/" + name ;
      result[n].alt = name;
    };
  },

  //---------------------------------------------------------------------------

  setKeyListener: function(keys) {

    var onkey = function(keyCode, mode) {
      var n, k;
      for(n = 0 ; n < keys.length ; n++) {
        k = keys[n];
        k.mode = k.mode || 'up';
        if ((k.key == keyCode) || (k.keys && (k.keys.indexOf(keyCode) >= 0))) {
          if (k.mode == mode) {
            k.action.call();
            return true;
          }
        }
      }
    };

    Dom.on(document, 'keydown', function(ev) { onkey(ev.keyCode, 'down')? ev.preventDefault(): null;  } );
    Dom.on(document, 'keyup',   function(ev) { onkey(ev.keyCode, 'up')?   ev.preventDefault(): null;  } );
  },

//---------------------------------------------------------------------------


//                          M  O  B   I   L   


//---------------------------------------------------------------------------

  mobil : (function(){
    var iconMobil = document.getElementById('icon-mobil'),
        iBlock    = document.getElementById('iblock');

    var init = function(){
      var CONST_KEYS = {
          qwe : ["q", "w","e","r","t","y","u","i","o","p"],
          asd : ["a","s","d","f","g","h","j","k","l"],
          zxc : ["z","x","c","v","b","n","m"],
          ispace  : ["space"],
          ireturn : ["\n"],
          iback   : ['BS']
      };      
      var iCanvas   = document.getElementById('icanvas'),
          ictx      = iCanvas.getContext('2d'),
          img       = Game.loadImages.iphone,
          size      = 1,
          width     = iCanvas.width  = img.width*size,
          height    = iCanvas.height = img.height*size,
          allKeys   = document.getElementById('ikeys'),
          iSend     = document.getElementById('isend'),
          iRead     = document.getElementById('iread'),
          poslanoSMS= 0;

      var pocet, fragment, table, td, row;
      var insms = document.getElementById('insms').getElementsByTagName('pre')[0];
      var outsms = document.getElementById('outsms').getElementsByTagName('pre')[0];


    /* DEV DEV  */ 
      ictx.globalAlpha = 0.85;
      ictx.drawImage(img,0,0,width, height);

      for (row in CONST_KEYS){
        pocet = CONST_KEYS[row].length;
        fragment = document.createDocumentFragment();
        table = document.createElement('table');
        tr = document.createElement('tr');
        table.appendChild(tr);
        for (var i = 0; i < pocet; i++) {
          td = document.createElement('td');
          td.innerHTML = CONST_KEYS[row][i];
          tr.appendChild(td); 
        };
        fragment.appendChild(table);
        document.getElementById(row).appendChild(fragment);
      };

      allKeys.onclick = function(event){
        var outSmsWrap  = outsms.parentElement,
            elem = event.target,
            letter;
        if (elem.tagName != 'TD') return;
        letter = elem.innerHTML;    
        if (letter ==="BS") { 
          outsms.innerHTML = outsms.innerHTML.substring(0, outsms.innerHTML.length-1)
        } else if (letter ==="space") {  outsms.innerHTML = outsms.innerHTML + " " 
        } else {   outsms.innerHTML = outsms.innerHTML + letter;
        };
        outSmsWrap.scrollTop = outSmsWrap.scrollHeight - outSmsWrap.clientHeight;
      }; // allKeys.onClick

      iconMobil.onclick = function(){
        this.className = ""
        Game.mobil.toggle();
        readSMS();
      };


/************      vARIANTA 1  *****************/
    var incomeSMS = [
            {"jeden": ["Prvni dotaz", "DRUHY DOTAZ\n "]},
            {"dva": ["Prvni dotaz", "DRUHY DOTAZ\n"]},
            {"tri": ["PRvNI dotaz 3", "DRUHY DOTAZ 3\n "]},
            {"ctyri": ["Prvni dotaz 4", "DRUHY DOTAZ 4\n"]}
      ];
    var readSMS =  (function() {
      iSend.onclick = function() {
        Game.mobil.toggle();
        if (Util.rasstoyanieLevenstejna(outsms.innerHTML, sms)) {
          console.info("\n                          ----SMS JE SPRAVNA ---\n")
          lastSMS = null;  
          if (++poslanoSMS > 2) konecHry();
        } else {
          console.info('ODPOVED NENI SPRAVNA, POSLAT ZASE S<MS')
          setTimeout(Game.mobil.newSMS, 6500);
        } 
        outsms.innerHTML = "";
      };
      var lastSMS = null,
          prevSMS = [];
      var sms;

      return function() {
        if ( lastSMS == null ) {
          while ((incomeSMS.length == prevSMS.length? !(prevSMS.length=0) : true)) {
            lastSMS = incomeSMS.random();
            if (prevSMS.indexOf(lastSMS)+1) continue;
            prevSMS.push(lastSMS);
            break;  
          }
          /* new array pro stare sms? */
          console.info("N O V A    R A N D O M    SMS ! ")
          for (sms in lastSMS) {
            devOdpoved.innerHTML =  sms; 
            insms.innerHTML = lastSMS[sms][0];
          };
        } else if (insms.innerHTML !== "")  insms.innerHTML =  lastSMS[sms][1];
      }; 
      
    })();

/************      vARIANTA 1  *****************/




/************      vARIANTA 2  ****************
      var incomeSMS = [
            {"Odpoved": ["Prvni dotaz ", "DRUHY DOTAZ"]}
      ];
      var readSMS =  (function() {
        iSend.onclick = function() {
          if (isSMSCorect(predsms['answer'][0])) {
            Game.mobil.toggle();
            if (++poslanoSMS > 2) konecHry();
          } else readSMS(); 
        };
        var isSMSCorect = function(spravnaSMS){ return ( outsms.innerHTML.toLocaleLowerCase() === spravnaSMS.toLocaleLowerCase()); };
        var predsms = null;
        return function() {
          if ( predsms == null ) {
            predsms = predsms = incomeSMS.random();
              insms.innerHTML = predsms['questions'][0]                
              devOdpoved.innerHTML =  predsms['answer'][0]; 
          } else if (insms.innerHTML !== "")  insms.innerHTML =  predsms["questions"][1];
        }; 
      })();
******************************************/

      iRead.onclick = readSMS;
    }; // konec init


    return  {
      init : init,
      toggle : function(noShow){
          var smskuje = !(~iBlock.className.indexOf('show'));
          iBlock.className =smskuje ? 'show'  : '';
          this.smskuje = smskuje;
      },
      newSMS: function(){
        iconMobil.className = "newsms";
      },
      smskuje : false
    };
          
  })(), // end Mobil


//----------------------vORG-----------------------------------------------------



  timer : (function(){
/*    var showMobile = function(score){
      var pocetBran = 0;
      for (var i = score.length - 1; i >= 0; i--) {
        if ((score[i]).smskuje) {
          pocetBran = 0; break;
        } else if (pocetBran++ >=3) { 
          pocetBran = 0;
          Game.mobil.newSMS.call(Game.mobil)
          break;
        };
      };
    };
*/  
    var actualBrana ,score = [], segment,
         lastBrana= 0, pocetBran=0;
    var convert = function(x){ return Math.round((.8 + x)/.4) };
    var pruhy = new Array(lanes);
    for (var i=0; i<pruhy.length; i++) {
      pruhy[i] = i;
    };
    return {
      start : function(nejBrana){
        segment = nejBrana;
        actualBrana = nejBrana.sprites[0];
        var actualPruh = convert(playerX);
        var volnePruhy = [];
        for (var i=0; i<lanes; i++) {
          if (lastBrana === i) continue;
          if ((zataci) && ( convert(pruh)===i )) continue
          else if (actualPruh === i) continue;
          volnePruhy.push(i);
        };
        actualBrana.gate  = volnePruhy.random();
        actualBrana.start = Util.timestamp();
        actualBrana.end = null;
      },
      end : function(gate){
        if (actualBrana && (actualBrana.end === null) && (actualBrana.gate === convert(gate) )) {
          actualBrana.end = (Util.timestamp() - actualBrana.start)/1000;
        }
      },
      prejezd : function(playerX){
        var newScore = {
            time: actualBrana.end || 0,
            projel  : actualBrana.end ? actualBrana.gate === convert(playerX):false,
            smskuje : Game.mobil.smskuje,
            segm    : segment.index,
            maxReactTime : ((Util.timestamp() - actualBrana.start)/1000).toFixed(2)
        };
        if (actualBrana ) { 
          score.push(newScore);
          var l= score.length;
          /* pokud posledni 3 brany neSMSkoval, poslat newSMS */
          if ((l>=3) && !((score[l-1].smskuje) || (score[l-2].smskuje) || (score[l-3].smskuje)) ) { 
            Game.mobil.newSMS();
          }
        }
        actualBrana = null;
        segment.sprites = []; // smazat bran
        pridejBranu(segment.index);
        showScoreOnline(newScore);
      },
      score: score
    }
  })()
//---------------------------------------------------------------------------

}; // Game






//=========================================================================
//                     R E N D E R
//=========================================================================

var Render = {

  polygon: function(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    ctx.fill();
  },

  //---------------------------------------------------------------------------

  segment: function(ctx, width, lanes, x1, y1, w1, x2, y2, w2, fog, color) {

    var r1 = Render.rumbleWidth(w1, lanes);
    var r2 = Render.rumbleWidth(w2, lanes);
    var l1 = Render.laneMarkerWidth(w1, lanes);
    var l2 = Render.laneMarkerWidth(w2, lanes);
    var    lanew1, lanew2, lanex1, lanex2, lane;
    
    ctx.globalAlpha = 1;
    ctx.fillStyle = color.grass;
    ctx.fillRect(0, y2, width, y1 - y2);

    Render.fog(ctx, 0, y1, width, y2-y1, fog);    
    Render.polygon(ctx,  x1-w1-r1, y1,   x1-w1, y1,    x2-w2, y2,    x2-w2-r2, y2,   color.rumble);  // leva bordura
    Render.polygon(ctx, x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);    // prava bordura
    Render.polygon(ctx, x1-w1,    y1, x1+w1, y1, x2+w2, y2, x2-w2,    y2, color.road);
    

    // BILE PRUHY UPROSTRED DALNICE
    if (color.lane) {
      lanew1 = w1*2/lanes;
      lanew2 = w2*2/lanes;
      lanex1 = x1 - w1 + lanew1;
      lanex2 = x2 - w2 + lanew2;
      for(lane = 1 ; lane < lanes ; lanex1 += lanew1, lanex2 += lanew2, lane++)
        Render.polygon(ctx, lanex1 - l1/2, y1, lanex1 + l1/2, y1, lanex2 + l2/2, y2, lanex2 - l2/2, y2, color.lane);
    }
    
   Render.fog(ctx, 0, y1, width, (y2-y1), fog , '#000');   
    
  },

  //---------------------------------------------------------------------------

  spritesObjects : function(segment, opacity){
            var img = segment.sprites[0].source;  
            var sprite      = segment.sprites[0];
            var gate        = sprite.gate;

            var scale = segment.p1.screen.scale;
            var spriteX     = segment.p1.screen.x + (scale *(sprite.offset||0) *  roadWidth * width/2);
            var spriteY     = segment.p1.screen.y ;

            var destW  = (img.width  * scale * width) * ((1/img.width) * roadWidth);
            var destH  = (img.height * scale * width) * ((1/img.width) * roadWidth); 
            var destX = spriteX - ( destW /2 ); 
            var destY = spriteY - ( destH ); 
            var clipH =  segment.clip ? Math.max(0, destY+destH-segment.clip) : 0;

            if (clipH >= destH) return

            Render.branu(img, destX, destY, destW, destH - clipH, opacity, segment.clip); 

            if (gate === undefined) return;

            destW  = (img.width  * scale * width/lanes) * ((1/img.width) * roadWidth);
            Render.spravnyPruh(img, destX, destY ,  destW, destH - clipH, opacity,sprite )
  },

   branu : function(img, destX, destY ,  destW, destH, opacity, clipY ){
      opacity = Math.min(1,opacity*1.2);
      ctx.globalAlpha = opacity;
      ctx.drawImage(img, destX, destY , destW, destH);

  },

  spravnyPruh : function(img, destX, destY ,  destW, destH, opacity, sprite ){
      var simafor = sprite.start? Game.loadImages.green : Game.loadImages.red,
          gate =  sprite.gate;


      ctx.globalAlpha = opacity*.5;
      for (var i = 0; i < lanes; i++) ctx.drawImage(Game.loadImages.red, destX +  (destW*i), destY , destW, destH/3);        

      /* jen tak*/
      if (sprite.start) {
          ctx.globalAlpha = 1;
          ctx.strokeStyle="#40cc20"
          ctx.lineWidth = 3
       } else {
          ctx.globalAlpha = opacity// 0.2
          ctx.strokeStyle="#f00"
          ctx.lineWidth = 1;
      }

      destX = destX +  (destW*gate)
      ctx.drawImage(simafor, destX, destY , destW, destH/2.25);

      ctx.setLineDash([8, 10]);
      ctx.strokeRect( destX, destY , destW, destH )
      ctx.setLineDash([]); ctx.lineWidth = 1;
      ctx.globalAlpha = 1
  },


  kontura : function(destX, destY , destW, destH){
        /*   obvod cele brany */
        ctx.beginPath();
        ctx.strokeStyle= '#999';
        ctx.strokeRect(destX, destY , destW, destH);
        ctx.closePath()
  },

  //---------------------------------------------------------------------------

  fog: function(ctx, x, y, width, height, fog, color) {
    if (fog < 1) {
      height = color? height : height;
      ctx.globalAlpha = color? (1-fog)*.35 : (1-fog);
      ctx.fillStyle = color || COLORS.FOG;
      ctx.fillRect(x, y, width, height);
      ctx.globalAlpha = 1;
    }
  },

  rumbleWidth:     function(projectedRoadWidth, lanes) { return projectedRoadWidth/Math.max(6,  2*lanes); },
  laneMarkerWidth: function(projectedRoadWidth, lanes) { return projectedRoadWidth/Math.max(32, 8*lanes); }

}








//=============================================================================
// RACING GAME CONSTANTS
//=============================================================================
          var PRVNI_BRANY = [0,350]
          var KEY = {
              LEFT:  37,  /*A:     65,*/
              UP:    38,  /*D:     68,*/
              RIGHT: 39,  /*S:     83,*/
              DOWN:  40,  W:     87,  E:69,
              A: 65, S: 83, D: 68, F: 70, G: 71,
              1: 49, 2: 50, 3: 51, 4: 52, 5: 53
            };

          var COLORS = {
              SKY:  '#72D7EE',
              TREE: '#005108',
              // FOG: 'rgba( 169, 203, 233,.9)',  // '#2a4c60',
              FOG: 'rgba( 36, 93, 142, .9)',  // '#2a4c60',
              LIGHT:  { road: '#5B6B6B', grass: '#009aca', rumble: '#555', lane: '#ACCCCC'  },
              DARK:   { road: '#696969', grass: '#026767', rumble: '#BBB'                   },
              START:     { road: '#40cc40',   grass: 'white',   rumble: 'white'                  },
              MY:     { road: '#40cc40',   grass: 'white',   rumble: 'white'                  },
              FINISH: { road: 'black',   grass: 'black',   rumble: 'black'                  }
            };
  /* Canvas a IMGs */
          var fps           = 60;                      // how many 'update' frames per second
          var step          = 1/fps;                   // how long is each frame (in seconds)
          var segments      = [];                      // array of road segments
          var canvas        = element('canvas');       // our canvas...
          var ctx           = canvas.getContext('2d');
          ctx.save();
          var width         = 1024;                    // logical canvas width
          var height        = 768;                     // logical canvas height
              canvas.width  = width
              canvas.height = height

          var imgElements  = {}    
          var sprites       = null;                    // our spritesheet (loaded below)
          /*var resolution    = null;     // pokud potrebujem ruzne verze podle vykonosti , t.j.  resolution    = height/(height*500);
          */    

  /* DALNICE a Camera */    
          var roadWidth     = 2000;                    // actually half the roads width, easier math if the road spans from -
          var segmentLength = 200;     
          var  segments = [];                // length of a single segment
          var rumbleLength  = 3;                       // number of segments per red/white rumble strip // strip = полосa
          var trackLength   = null;                    // cela dalnice, t.j. 1 kolo.  z length of entire track (computed) track = trassa
          var lanes         = 5;                       // number of lanes
          var fieldOfView   = 85;                     // eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeangle (degrees) for field of view
          var cameraHeight  = 600;                    // z height of camera.;from screen (computed)
              cameraDepth  = 1 / Math.tan((fieldOfView/2) * Math.PI/180);

          var drawDistance  = 1000;                     // number of segments to draw
          var fogDensity    = 1000;                       // exponential fog density
          var playerX       = 0;                       
                                                   
          var playerZ       = null;                    // player relative z distance from camera (computed)
              playerZ       = (cameraHeight * cameraDepth);

  /* Rizeni */
          var position      = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
          var speed         = 0*100;                 // current speed
          var maxSpeed      = 10000//segmentLength/step ;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)  // garance min 1 segment v 1 snimek

          var accel         =  maxSpeed/5;             // acceleration rate - tuned until it 'felt' right ..ускорения - 
          var breaking      = -maxSpeed;               // deceleration rate when braking   // замедление 

          var keyLeft       = false;
          var keyRight      = false;
          var keyFaster     = false;
          var keySlower     = false;

          var activeKey      = null //vypocetava se4
          var key1           = false,
              key2           = false,
              key3           = false,
              key4           = false,
              key5           = false;
          var zataci = false;
          var pruh   = null;
          var zrychleni = 1;
          var nejBrana
          var nextSegmentBrany= 600
          var segmentsDalnice   = 2000
          var vyskaDalnice      = 0  
          var segZa2sek         = speed * 0.0125;
          var skyOffset = 0

          var fly= {};
              fly.down = false;
              fly.up   = false;

        
        var incomeSMS = [
        ];





  //=========================================================================
  //=========================================================================
  //=========================================================================

     function lastY() {
        return (segments.length == 0) ? 0 : segments[segments.length-1].p2.world.y;
      };

  //=========================================================================

      function addRoad(enter, hold, leave, y, curve ) {
          var startY   = lastY();
          var endY     = startY + (Util.toInt(y, 0) * segmentLength);
          var n, total = enter + hold + leave;
          for(n = 0 ; n < enter ; n++) { 
            addSegment( Util.easeInOut(startY, endY, n/total), 
            Util.easeIn(0, curve, n/total)); 
          };
          for(n = 0 ; n < hold  ; n++) {
            addSegment(Util.easeInOut(startY, endY, (enter+n)/total) ,
            curve);
          };
          for(n = 0 ; n < leave ; n++) {
            addSegment( Util.easeInOut(startY, endY, (enter+hold+n)/total),
            Util.easeInOut(curve, 0, n/leave)   ); 
          };
      };


  //=========================================================================

      function addSegment(y, curve) {
       var n  = segments.length
          segments.push({
             index: n,
             p1: { world: { y: lastY(),   z:  n   *segmentLength,   }, camera: {}, screen: {} },
             p2: { world: { y: y,         z: (n+1)*segmentLength,   }, camera: {}, screen: {} },
             curve : curve,
             sprites : [],
             color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
          });
      };

  //=========================================================================

      var resetRoad = function(){
        var random = function(x){
          return Math.floor(Math.random()*x)
        }
        addRoad(200, segmentsDalnice/5 -300, 100  , -25  ,  random(15)/15); // pridani dalnice
        addRoad(100, segmentsDalnice/5 -300, 200  , 20   ,  random(-15)/15); // pridani dalnice
        addRoad(230, segmentsDalnice/5 -300, 70   , -5   ,  random(5)/15); // pridani dalnice
        addRoad(75, segmentsDalnice/5  -300, 225  , 20   ,  random(15)/15); // pridani dalnice
        addRoad(200, segmentsDalnice/5 -300, 100  , -10  ,  random(-15)/15); // pridani dalnice

        trackLength = segments.length * segmentLength;
      };

  //=========================================================================

      function findSegment(z) {
        return segments[Math.floor(z/segmentLength) % segments.length];
      };

  //=========================================================================
      function findNejblizsiBranu (idx)  {
        for (var i = 0; i < drawDistance; i++) {
          var segment = segments[(idx + i) % segments.length];
          if (segment.sprites.length !== 0) return segment;
        };
        return false
      };

  //=========================================================================


      function pridejBranu (segIndex){
        if ( segIndex  instanceof Array ) {
          for (var i = 0; i < segIndex.length; i++) pridejBranu(segIndex[i]);
          return;
        };
        var index =  (segIndex + nextSegmentBrany >= segmentsDalnice)
             ? segIndex + nextSegmentBrany  - segmentsDalnice
             : segIndex + nextSegmentBrany;
        segments[index].sprites.push({ source: Game.loadImages.brana, offset: 0 }); 
      };


    //=========================================================================

      function accelerate(){
        /* nejprve zvetsime rychlost na maximalni, pak zmerime kolik projede za 2.5 sek
           a ulozim do vzdalenost2sek pak udelame reset dalnice a smazeme func accelerate */
        if ( speed  < maxSpeed) {
          speed += 32 //Math.floor(speed/100);
        } else {
          accelerate = null;
          segZa2sek = speed* 0.0125
        };
      };

    //=========================================================================

      function changeLanes(dx){
          if  (activeKey  !== null) {
            /* pokud v dobe zataceni, se vyberou jiny pruh, tak prepocitat zrychleni */
            if (pruh !== null && (pruh !== activeKey)) zataci = false;
            pruh =  activeKey;
          };
          if (!zataci) zrychleni = +Math.abs((playerX - activeKey)/0.4/2).toFixed(2);
          
          if (playerX !=  pruh ) {
              zataci = true;
              dx = +(dx * (zrychleni)).toFixed(7);
              playerX =  +(playerX + ((pruh - playerX) > 0 ? dx : 0-dx)).toFixed(3)
              var rozdil = +(playerX - pruh ).toFixed(2);
              if ((rozdil >= -0.01) && (rozdil <= 0.01 )) playerX = pruh;
            } else {
              zataci = false;
              zrychleni = 1;
              pruh = null;
          };
      };

    //=========================================================================

      function vypocetProjekce (p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        /*  cameraX : (playerX * roadWidth), 
            cameraY : cameraHeight,
            cameraZ : position - (segment.looped ? trackLength : 0),
        */
        p.camera.x     = (p.world.x || 0) - cameraX;
        p.camera.y     = (p.world.y || 0) - cameraY;
        p.camera.z     = (p.world.z || 0) - cameraZ;
        p.screen.scale = cameraDepth/p.camera.z;
        p.screen.x     = Math.round((width/2)  + (p.screen.scale * p.camera.x  * width/2));
        p.screen.y     = Math.round((height/2) - (p.screen.scale * p.camera.y  * height/2));
        p.screen.w     = Math.round(             (p.screen.scale * roadWidth   * width/2));
      };


    //=========================================================================
    //        U P D A T E      -----        U P D A T E
    //=========================================================================


    function update(dt) {
      position = Util.increase(position, dt * speed, trackLength);
      var dx = +(dt * (speed/maxSpeed)).toFixed(3) ;    
      var baseSegment = findSegment(position);
      skyOffset  = Util.increase(skyOffset,  0.001  * baseSegment.curve , 1);

      if (accelerate) { accelerate(); return };
     
      if (!nejBrana) nejBrana = findNejblizsiBranu(baseSegment.index);
      if (nejBrana) {
        if ((baseSegment.index + segZa2sek >  (nejBrana.looped?nejBrana.index+segmentsDalnice:nejBrana.index)) && (!nejBrana.sprites[0].start)) 
          Game.timer.start(nejBrana)
      };


      if ((activeKey !== null) && (nejBrana)) Game.timer.end(activeKey)

      if (baseSegment.sprites.length) nejBrana = Game.timer.prejezd(playerX)

      if ((activeKey !== null) || (zataci)) changeLanes(dx);   /* zmena celeho pruhu  */

      // doscanaFunc({ dt:dt, dx:dx });  // rucni zmena pruhu  DEV 
    };



    //=========================================================================
    //                  R E N D E R    -----    R E N D E R   
    //=========================================================================

    var render =  function() {
            
      var baseSegment   = findSegment(position);
      var playerSegment = findSegment(position+playerZ);
      var playerPercent = Util.percentRemaining(position+playerZ, segmentLength);
      var basePercent   = Util.percentRemaining(position, segmentLength);
      var playerY       = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
      var maxy          = height;

      /*dev*/ meritko.innerHTML ='<b> Y= </b>' + playerY.toFixed(2);

      /* render background*/
      imgW  = Game.loadImages.sky.width*0.5
      imgH  = Game.loadImages.sky.height;
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(Game.loadImages.sky, 400 + skyOffset*400 ,0, imgW , imgH// ); //background
                                       , 0  ,0, width, height /1.9);
      var n, segment;
      var x = 0,  dxx = - (baseSegment.curve * basePercent);

      /*render road */
      for(n = 0 ; n < drawDistance ; n++) {
        segment        = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n/drawDistance, fogDensity);
        segment.clip   = maxy;
        

        vypocetProjekce(segment.p1, (playerX * roadWidth) - x,       playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth , width, height, roadWidth);
        vypocetProjekce(segment.p2, (playerX * roadWidth) - x - dxx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0),  cameraDepth, width, height, roadWidth, true);

        x  = x + dxx;
        dxx = dxx + segment.curve;  
        
        if (segment.p1.camera.z <= cameraDepth)  continue ; // behind us
        if (segment.p2.screen.y >= segment.p1.screen.y) continue
        if (segment.p2.screen.y >= maxy)  continue;

        Render.segment(ctx, width, lanes,
                       segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.w,
                       segment.p2.screen.x, segment.p2.screen.y, segment.p2.screen.w,
                       segment.fog, segment.color);
        maxy = segment.p1.screen.y;
      };//for



      /* render objekty na dalnice, promena v cyklu musi klesat, aby blizke objekty, prekryli dalni  */
      for (n = drawDistance - 1; n >= 0; n--) 
{      segment        = segments[(baseSegment.index + n) % segments.length];
          for(var i = 0 ; i < segment.sprites.length ; i++) {
            var opacity = (baseSegment.index <= segment.index)
                ? baseSegment.index - segment.index
                : baseSegment.index - ( segment.index + segmentsDalnice);
            opacity = 1 - Math.abs(opacity /1000);
            Render.spritesObjects(segment,opacity );
          };
      };

      last = Util.timestamp();
    } ; // KONEC RENDER




/**********  DOCASNA FUNKCE  **********/
  function konecHry() {

    var  scoreArr = Game.timer.score.copy(),
         inc = 0;
    var scoreWrap = document.getElementById('score-wrap');
    var style = scoreWrap.style
    style.display = "block";

      nejBrana= null
      for (var i = segments.length - 1; i >= 0; i--) {
        segments[i].sprites = [];
      };

    var interval  = setInterval(function(){
        speed = speed+50;
        document.getElementById('score-online').style.opacity = 1 - inc*.01
        cameraHeight = Util.easeIn(1,inc*10 ,2)+600;
        style.opacity = inc*0.01;
        cameraDepth = 1.09- inc*0.005;
        if (inc != 100)  inc++
        else { 
          clearInterval(interval);
          speed = 500;
          showScore();
        }
    },25);

    function showScore(){
      function makeTable(type,spans){
        spans[1].innerHTML = score[type].pocet;  
        spans[2].innerHTML = score[type].projel  
        spans[3].innerHTML = +score[type].time.toFixed(2) + ' sek | ' + +(score[type].time/score[type].pocet ||0).toFixed(2) + " sek";  
      };
      var item, type;
      var score = {
        sSMS  : { projel: 0, time: 0, pocet:0 },
        bezSMS: { projel: 0, time: 0, pocet:0 },
      };
      for (var i = 0; i < scoreArr.length; i++) {
        item =  scoreArr[i];
        type = item.smskuje? "sSMS" : "bezSMS";
        if (item.projel) score[type].projel++;
        if (item.time) score[type].time += item.time;
        score[type].pocet++;
      };
      var rows = scoreWrap.children[0].children[0].children;
      var index = 0
      for (var type in score) { makeTable(type,rows[++index].children) }
    };



  };



  </script>
  <div id="score-wrap">
   <div>
    <div>
        <div><span>       </span>   <span>Pocet bran</span> <span>Projel sis spravne</span>  <span> celkova / prum. reakce</span></div>
        <div><span>S   SMS</span>   <span>  </span> <span></span>  <span>  </span></div>
        <div><span>Bez SMS</span>   <span>  </span> <span></span>  <span>  </span></div>
   </div>
  </div>
  </div>
  <script src="delete.js"></script>
</body> 

