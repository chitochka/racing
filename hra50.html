<!DOCTYPE html> 

<html>
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="myDEv.css" rel="stylesheet" type="text/css" />
</head> 

<body> 
  <!-- myDev -->
  <div id="myDev">
    <span id="myspan"> </span>
    <span id="myspan1"> </span>
    <span id="myspan2"> </span>
    <span id="myspan3"> </span>
  </div>
<div id="myfps"></div>    
<!-- ebd myDev -->  

  <div id="racer">
    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>
    <!-- <img src="sky.jpg"/> -->
    <div id="meritko">50% 512px</div>
  </div>

  <script src="http://1gr.cz/js/uni/uni.js?rr={rndJS}"></script>
  <script src="stats.js"></script>
  <script src="myDev.js"></script>
  <script>

//=========================================================================
// DOM - pomocky , doladit element

var Dom = {
  set:  function(id, html)               { element(id).innerHTML = html;                        },
  on:   function(ele, type, fn, capture) { element(ele).addEventListener(type, fn, capture);    },
  un:   function(ele, type, fn, capture) { element(ele).removeEventListener(type, fn, capture); },
  show: function(ele, type)              { element(ele).style.display = (type || 'block');      },
  blur: function(ev)                     { ev.target.blur();                                    },
}

//=========================================================================
// Math-pomocky

var Util = {
  timestamp:        function()                  { return new Date().getTime();                                    },
  limit:            function(value, min, max)   { return Math.max(min, Math.min(value, max));                     },
  accelerate:       function(v, accel, dt)      { return v + (accel * dt);                                        },
  exponentialFog:   function(distance, density) { return 1 / (Math.pow(Math.E, (distance * distance * density))); },
  increase:  function(start, increment, max) { // with looping
    var result = start + increment;
    while (result >= max)
      result -= max;
    while (result < 0)
      result += max;
    return result;
    }
  }

  var vypocetProjekce = function(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
    /*
    cameraX : (playerX * roadWidth), 
    cameraY : cameraHeight,
    cameraZ : position - (segment.looped ? trackLength : 0),
    */

    p.camera.x     = (p.world.x || 0) - cameraX;
    p.camera.y     = (p.world.y || 0) - cameraY;
    p.camera.z     = (p.world.z || 0) - cameraZ;
    /*  scale = zDistanceToScreen / ObjectZ  */
    p.screen.scale = cameraDepth/p.camera.z ;
    p.screen.x     = Math.round((width/2)  + (p.screen.scale * p.camera.x  * width/2));
    p.screen.y     = Math.round((height/2) - (p.screen.scale * p.camera.y  * height/2));
    p.screen.w     = Math.round(             (p.screen.scale * roadWidth   * width/2));
  hh = p.screen.h  = Math.round(             (p.screen.scale * branaHeight   * height/2)); 
    if (hh >= 0 ) hhArr.push(hh)

  };



//=========================================================================
// GAME LOOP helpers
//=========================================================================

var Game = {  // a modified version of the game loop from my previous boulderdash game - see http://codeincomplete.com/posts/2011/10/25/javascript_boulderdash/#gameloop

  run: function(options) {

    Game.loadImages(options.images, function(images) {

      options.ready(images); // tell caller to initialize itself because images are loaded and we're ready to rumble
      //скажите вызывающему инициализировать себя, потому что загружаются изображения, и мы готовы к бою

      Game.setKeyListener(options.keys);

      var canvas = options.canvas,    // canvas render target is provided by caller.  //Холст визуализации цели обеспечивается вызывающим абонентом.
          update = options.update,    // method to update game logic is provided by caller. //Метод для обновления игровую логику обеспечивается вызывающим абонентом.
          render = options.render,    // method to render the game is provided by caller. // Метод для визуализации игры обеспечивается вызывающим абонентом.
          step   = options.step,      // fixed frame step (1/fps) is specified by caller. //// Фиксированный шаг кадра (1 / кадров в секунду) задается вызывающим абонентом.
          stats  = options.stats,     // stats instance is provided by caller.    //// Статистика экземпляра предоставляется абонентом.

          now    = null,
          last   = Util.timestamp(),
          dt     = 0,
          gdt    = 0;


      /* Основная идея состоит в том, чтобы накопить наш dt пока это не больше, чем наше желаемое зафиксировало timestep, звонить update с фиксированным timestep, и переносят остаток, чтобы накопиться в следующий раз. */
      function frame() {
        now = Util.timestamp();
        dt  = Math.min(1, (now - last) / 1000); // using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab
        // С помощью requestAnimationFrame должны быть в состоянии обрабатывать большие треугольник это вызвано, когда он 'в спящий режим' в в фоновом или невидимой вкладке
        gdt = gdt + dt;
        
        while (gdt > step) {   /*  ?? */
          gdt = gdt - step;
          update(step);
        }
        render();
        stats.update();
        last = now;
        requestAnimationFrame(frame, canvas);
      }
      frame(); // lets get this party started
    });
  },

  //---------------------------------------------------------------------------

  loadImages: function(names, callback) { // load multiple images and callback when ALL images have loaded
    var result = [];
    var count  = names.length;

    var onload = function() {
      if (--count == 0)
        callback(result);
    };

    for(var n = 0 ; n < names.length ; n++) {
      var name = names[n];
      result[n] = document.createElement('img');
      Dom.on(result[n], 'load', onload);
      if (name.startsWith('jpg') )
        { result[n].src = "images/" + name + ".jpg" }
      else result[n].src = "images/" + name + ".png";

    }
  },

  //---------------------------------------------------------------------------

  setKeyListener: function(keys) {
    var onkey = function(keyCode, mode) {
      var n, k;
      for(n = 0 ; n < keys.length ; n++) {
        k = keys[n];
        k.mode = k.mode || 'up';
        if ((k.key == keyCode) || (k.keys && (k.keys.indexOf(keyCode) >= 0))) {
          if (k.mode == mode) {
            k.action.call();
            return true;
          }
        }
      }
    };
    Dom.on(document, 'keydown', function(ev) { 
      onkey(ev.keyCode, 'down')? ev.preventDefault(): null;  
    } );
    Dom.on(document, 'keyup',   function(ev) { onkey(ev.keyCode, 'up')?   ev.preventDefault(): null;  } );
  },

  //---------------------------------------------------------------------------

  stats: function(parentId, id) { // construct mr.doobs FPS counter - along with friendly good/bad/ok message box

    var result = new Stats();
    result.domElement.id = id || 'stats';
    element(parentId).appendChild(result.domElement);

    var msg = document.createElement('div');
    msg.style.cssText = "border: 2px solid gray; padding: 5px; margin-top: -5px; text-align: center; font-size: 1.5em;";
    element(parentId).appendChild(msg);

    var value = document.createElement('span');
    value.innerHTML = "...";
    msg.appendChild(value);

    setInterval(function() {
      var fps   = result.current();
      var ok    = (fps > 50) ? 'good   :-) '  : (fps < 30) ? 'bad   :-(' : 'uspokojeně';
      var color = (fps > 50) ? '#40cc40'      : (fps < 30) ? 'red'       : 'gray';
      var txt = (fps > 50)   ? '#0C280C'      : (fps < 30) ? '#330000'   : 'black';
      value.innerHTML         = ok;
      value.style.background  = txt
      msg.style.background    = color;
      msg.style.color = 'yellow';
    }, 5000);
    return result;
  },

}




//=========================================================================
// canvas rendering helpers
//=========================================================================

var Render = {

  polygon: function(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
    /* dalnice */
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    ctx.fill();
  },

  //---------------------------------------------------------------------------

  segment: function(ctx, width, lanes, x1, y1, w1, x2, y2, w2, fog, color) {

    var r1 = Render.rumbleWidth(w1, lanes);
    var r2 = Render.rumbleWidth(w2, lanes);
    var l1 = Render.laneMarkerWidth(w1, lanes);
    var l2 = Render.laneMarkerWidth(w2, lanes);
    var    lanew1, lanew2, lanex1, lanex2, lane;
    
    ctx.fillStyle = color.grass;
    ctx.fillRect(0, y2, width, y1 - y2);
    
    Render.polygon(ctx, x1-w1-r1, y1, x1-w1, y1, x2-w2, y2, x2-w2-r2, y2, color.rumble);  // leva bordura
    Render.polygon(ctx, x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);    // prava bordura
    Render.polygon(ctx, x1-w1,    y1, x1+w1, y1, x2+w2, y2, x2-w2,    y2, color.road);

    // BILE PRUHY UPROSTRED DALNICE
    if (color.lane) {
      lanew1 = w1*2/lanes;
      lanew2 = w2*2/lanes;
      lanex1 = x1 - w1 + lanew1;
      lanex2 = x2 - w2 + lanew2;
      for(lane = 1 ; lane < lanes ; lanex1 += lanew1, lanex2 += lanew2, lane++)
        Render.polygon(ctx, lanex1 - l1/2, y1, lanex1 + l1/2, y1, lanex2 + l2/2, y2, lanex2 - l2/2, y2, color.lane);
    }
    
    //Render.fog(ctx, 0, y1, width, y2-y1, fog);
  },
 
  //---------------------------------------------------------------------------
  
  background: function(ctx) {
  // background: function(ctx, background, width, height, layer, rotation, offset) {
  var rand = Math.floor(Math.random()*2);
 ctx.drawImage(sky,rand/2,0, width, (height/2) +10);
  return

     /*  fon  
    rotation = rotation || 0;
    offset   = offset   || 0;

    var imageW = layer.w/2;
    var imageH = layer.h;

    var sourceX = layer.x + Math.floor(layer.w * rotation);
    var sourceY = layer.y
    var sourceW = Math.min(imageW, layer.x+layer.w-sourceX);
    var sourceH = imageH;
    
    var destX = 0; 
    var destY = offset;
    var destW = Math.floor(width * (sourceW/imageW));
    var destH = height;

    ctx.drawImage(background, sourceX, sourceY, sourceW, sourceH, destX, destY, destW, destH);
    if (sourceW < imageW) 
      ctx.drawImage(background, layer.x, sourceY, imageW-sourceW, sourceH, destW-1, destY, width-destW, destH);
    */
  },

  //---------------------------------------------------------------------------

  fog: function(ctx, x, y, width, height, fog) {
    if (fog < 1) {
      ctx.globalAlpha = (1-fog)
      ctx.fillStyle = COLORS.FOG;
      ctx.fillRect(x, y, width, height);
      ctx.globalAlpha = 1;
    }
  },
  //  rumbleWidth громыхание wiriny
  rumbleWidth:     function(projectedRoadWidth, lanes) { return projectedRoadWidth/Math.max(6,  2*lanes); },
  laneMarkerWidth: function(projectedRoadWidth, lanes) { return projectedRoadWidth/Math.max(32, 8*lanes); }

}

//=============================================================================
// RACING GAME CONSTANTS
//=============================================================================

var KEY = {
  LEFT:  37,  /*A:     65,*/
  UP:    38,  /*D:     68,*/
  RIGHT: 39,  /*S:     83,*/
  DOWN:  40,  /*W:     87,*/
  A: 65, S: 83, D: 68, F: 70, G: 71,
  1: 49, 2: 50, 3: 51, 4: 52, 5: 53
};

var COLORS = {
  SKY:  '#72D7EE',
  TREE: '#005108',
  FOG:  '#122b6a',
  LIGHT:  { road: '#5B6B6B', grass: '#00eaea', rumble: '#555', lane: '#ACCCCC'  },
  DARK:   { road: '#696969', grass: '#026767', rumble: '#BBB'                   },
  START:  { road: '#40cc40',   grass: 'white',   rumble: 'white'                  },
  FINISH: { road: 'black',   grass: 'black',   rumble: 'black'                  }
};

  </script>
  <script>

  /******////
  //   1 kadr = step     =  16 ms =  0.016 sek
    hhArr = []

    /*  Grlobal promeny  */
    /*  common.JS :  Dom ,  Util  , Game  ,  Render  ,  KEY  , COLORS   ,  BACKGROUND   , SPRITES  */

    /*var*/ fps           = 60;                      // how many 'update' frames per second
    /*var*/ step          = 1/fps;                   // how long is each frame (in seconds)
    /*var*/ segments      = [];                      // array of road segments
    /*var*/ stats         = Game.stats('myfps');       // mr.doobs FPS counter
    /*var*/ canvas        = element('canvas');       // our canvas...
    /*var*/ ctx           = canvas.getContext('2d');
    /*var*/ width         = 1024;                    // logical canvas width
    /*var*/ height        = 768;                     // logical canvas height
            canvas.width  = width
            canvas.height = height


     // ...and its drawing context
    /*var*/ background    = null;                    // our background image (loaded below)
            sky           = null;
    /*var*/ sprites       = null;                    // our spritesheet (loaded below)
    // /*var*/ resolution    = null;                    // scaling factor to provide resolution independence (computed)  // коэффициент масштабирования для предоставления разрешения независимости (вычисленоe    )
            // resolution    = height/(height*500);
            branaHeight   = 500;
    /*var*/ roadWidth     = 2000;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
                                                 //  фактически половина дороги шириной, легкое математика, если дорога простирается от -roadWidth до + roadWidth

    /*var*/ segmentLength = 200;                     // length of a single segment
    /*var*/ rumbleLength  = 3;                       // number of segments per red/white rumble strip // strip = полосa
    /*var*/ trackLength   = null;                    // cela dalnice, t.j. 1 kolo.  z length of entire track (computed) track = trassa
    /*var*/ lanes         = 5;                       // number of lanes
    /*var*/ fieldOfView   = 50;                     // angle (degrees) for field of view
    /*var*/ cameraHeight  = 700;                    // z height of camera.;from screen (computed)
             cameraDepth  = 1 / Math.tan((fieldOfView/2) * Math.PI/180);
    /*var*/ drawDistance  = 250;                     // number of segments to draw
    /*var*/ playerX       = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
                                                 //игрок Х смещение от центра дороги (от -1 до 1бы расположиться независимым от roadWidth)
    /*var*/ playerZ       = null;                    // player relative z distance from camera (computed)
            playerZ       = (cameraHeight * cameraDepth);



                                                 //игрок относительно z расстояния от камеры
    /*var*/ fogDensity    = 20;                       // exponential fog density
    /*var*/ position      = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
    /*var*/ speed         = 100;                       // current speed
    /*var*/ maxSpeed      =  segmentLength/step ;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)        = 12500
                                                  /* гарантируйте, что мы не можем двигаться более чем на 1 сегмент в одном кадре, чтобы сделать обнаружение коллизий легкое) */
    /*var*/ accel         =  maxSpeed/5;             // acceleration rate - tuned until it 'felt' right ..Темп ускорения - настроен, пока "не чувствовал" право
    /*var*/ breaking      = -maxSpeed;               // deceleration rate when braking   // замедление скорости при торможении
    /*var*/ decel         = -maxSpeed/5;             // 'natural' deceleration rate when neither accelerating, nor braking  //«Естественной» скорость замедления, когда ни ускорения, ни торможения
    /*var*/ offRoadDecel  = -maxSpeed/2;             // off road deceleration is somewhere in between   //бездорожье замедления где-то посередине
    /*var*/ offRoadLimit  =  maxSpeed/4;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)
                                                 //Ограничение при бездорожье

    /*var*/ keyLeft       = false;
    /*var*/ keyRight      = false;
    /*var*/ keyFaster     = false;
    /*var*/ keySlower     = false;

            activeKey      = null //vypocetava se
            key1           = false;
            key2           = false;
            key3           = false;
            key4           = false;
            key5           = false;
            var zataci = false;
            var pruh;
            
       //     SPRITES.SCALE = 0.3 * (1/(80/2))
            SPRITESSCALE = 0.333333 * (1/20) // the reference sprite width should be 1/3rd the (half-)roadWidth
            
            resetRoad();
    //=========================================================================
    // UPDATE THE GAME WORLD
    //=========================================================================

    function update(dt) {

      position = Util.increase(position, dt * speed, trackLength);
      /*dev*/ myspan1.innerHTML = 'position: <b>' + position.toFixed(1) +  '<b>';
      myspan2.innerHTML = 'speed = <b>' + speed + '</b>';
      var dx = dt * 2 * (speed/maxSpeed); // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
      var pozicePruhu = [-0.8, -0.4, 0 , 0.4, 0.8];

      if ( speed  < 12000) {
        speed += Math.floor(speed/100);
      };

   
      /* zmena celeho pruhu  */
      
      if ((activeKey !== null) || (zataci)) (function(activeKey){
         pruh = (activeKey  !== null) ? Math.floor(-8 + (4*activeKey))/10 :  pruh;
         if (playerX !=   pruh ) {
            zataci = true;
            playerX =  (playerX + ((pruh - playerX) > 0 ? .01 : -.01)).toFixed(3);
         } else {zataci = false}
      })(activeKey);

      /* rucni zmena pruhu */
      if (keyLeft)
        playerX = playerX - dx;
      else if (keyRight)
        playerX = playerX + dx;


      if (keyFaster)
        speed = Util.accelerate(speed, accel, dt);
      else if (keySlower)
        speed = Util.accelerate(speed, breaking, dt);
      else
        speed = Util.accelerate(speed, /*decel*/ 0, dt);

      if (((playerX < -1) || (playerX > 1)) && (speed > offRoadLimit))
        speed = Util.accelerate(speed, offRoadDecel, dt);

      playerX = Util.limit(playerX, -2, 2);     // dont ever let player go too far out of bounds
      speed   = Util.limit(speed, 0, maxSpeed); // or exceed maxSpeed

    }

    //=========================================================================
    // RENDER THE GAME WORLD
    //=========================================================================

    function render() {

      var baseSegment = findSegment(position);
      var maxy        = height;

      ctx.clearRect(0, 0, width, height);
      Render.background(ctx);

      var n, segment;

      for(n = 0 ; n < drawDistance ; n++) {
        segment        = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n/drawDistance, fogDensity);

        vypocetProjekce(segment.p1, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        vypocetProjekce(segment.p2, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        // if (maxy  < 400) debugger
        if ((segment.p1.camera.z <= cameraDepth) || // behind us
            (segment.p2.screen.y >= maxy))          // clip by (already rendered) segment
          continue;

        Render.segment(ctx, width, lanes,
                       segment.p1.screen.x,
                       segment.p1.screen.y,
                       segment.p1.screen.w,
                       segment.p2.screen.x,
                       segment.p2.screen.y,
                       segment.p2.screen.w,
                       segment.fog,
                       segment.color);

        maxy = segment.p2.screen.y;  /// ??
     
      };//for

      /***********  O B J E K T Y    N A  D A L N I C E  ***********/
     for(n = (drawDistance-1) ; n > 0 ; n--) {
      segment        = segments[(baseSegment.index + n) % segments.length];

      if (segment.sprites == 0 ) continue;
          
          var spriteSOURCE = segment.sprites[0].source;                 
          for(var i = 0 ; i < segment.sprites.length ; i++) {
            sprite      = segment.sprites[i];
            spriteScale = segment.p1.screen.scale;
            spriteX     = segment.p1.screen.x + (spriteScale * 0 * roadWidth * width/2);
            spriteY     = segment.p1.screen.y //+ (spriteScale *5* height/2);

            makeProjection(spriteSOURCE , spriteScale , spriteX , spriteY );
            // makeProjection(sprite.source , spriteScale , spriteX , spriteY );   kopie
          }
      }

    }  // KONEC RENDER


    var makeProjection = function(img , scale , destX , destY ){
                        //  scale for projection AND relative to roadWidth (for tweakUI)
        var destW  = (img.width*  scale * width/2 ) // * (SPRITESSCALE * roadWidth);
        var destH  = (img.height * scale * height/2) //* (SPRITESSCALE * roadWidth);
         /* tady pada, dopocitat projekce brany */ 
        destX = destX  + (destW * ( -2 || 0));
        destY = destY - (destH) // ( 0.001));

//          ctx.drawImage(sprites, sprite.x, sprite.y, sprite.w, sprite.h /*- (sprite.h*clipH/destH)*/, destX, destY, destW, destH );

          ctx.drawImage(img,
              // 0, sprite.y, img.w, img.h ,
              destX, destY, destW*4, destH
          );

//           ctx.fillRect(destX, destY, destW/2, destH)
    }

    /* docasna f*/
    function addSprite(n, sprite, offset) {
      segments[n].sprites.push({ source: sprite, offset: offset });
    };
  
    //=========================================================================
    // BUILD ROAD GEOMETRY
    //=========================================================================

    function resetRoad() {
      /* zavolat po   Starter.resize(funkce) */
      segments = [];
      // чтоб не было стробного эффекта ..........
      for(var n = 0 ; n < 500 ; n++) {
        segments.push({
           index: n,
           p1: { world: { z:  n   *segmentLength }, camera: {}, screen: {} },
           p2: { world: { z: (n+1)*segmentLength }, camera: {}, screen: {} },
           sprites : [],
           color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
        });
      }
          segments[findSegment(playerZ).index + 26].color = COLORS.START;
          segments[findSegment(playerZ).index + 3].color = COLORS.START;
    /*******************************************
            TADY NASTAVIT BRANU  /  SIMOFORY

    *******************************************/ 
     trackLength = segments.length * segmentLength;
    }

    function findSegment(z) {
      return segments[Math.floor(z/segmentLength) % segments.length];
    }

    //=========================================================================
    // THE GAME LOOP
    //=========================================================================
    run_attr = {canvas: canvas, render: render, update: update, stats: stats, step: step}

    Game.run({
      canvas: canvas, 
      render: render, update: update,
      stats: stats,
      step: step,
      images: ["background", "jpghory", "most"],  //rozdelit ong a jpg
      keys: [
        { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { keySlower = false; } },


        { keys: [KEY[1],  KEY.A], mode: 'down',   action: function() { activeKey = 0; } },
        { keys: [KEY[2],  KEY.S], mode: 'down',   action: function() { activeKey = 1; } },
        { keys: [KEY[3],  KEY.D], mode: 'down',   action: function() { activeKey = 2; } },
        { keys: [KEY[4],  KEY.F], mode: 'down',   action: function() { activeKey = 3; } },
        { keys: [KEY[5],  KEY.G], mode: 'down',   action: function() { activeKey = 4; } },
        { keys: [KEY[1],  KEY.A], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[2],  KEY.S], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[3],  KEY.D], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[4],  KEY.F], mode: 'up',   action: function() { activeKey = null; } },
        { keys: [KEY[5],  KEY.G], mode: 'up',   action: function() { activeKey = null; } }

      ],
      ready: function(images) {
        background = images[0];
        sky = images[1];
        brana = images[2];
        /*test*/ segments[30].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[100].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[101].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[102].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[160].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[181].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[250].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[400].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[420].sprites.push({ source: brana, offset: 0 });
        /*test*/ segments[180].sprites.push({ source: brana, offset: 0 });



      }
    });
    
  </script>

</body> 

