<!DOCTYPE html> 

<html>
<head>
  <title>Javascript Racer - v1 (straight)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <!-- <link href="common.css" rel="stylesheet" type="text/css" /> -->
  <link href="myDEv.css" rel="stylesheet" type="text/css" />
</head> 

<body> 
  <!-- myDev -->
  <div id="myDev">
    <span id="myspan"> </span>
    <span id="myspan1"> </span>
    <span id="myspan2"> </span>
    <span id="myspan3"> </span>
  </div>
<div id="fps"></div>    
<!-- ebd myDev -->  



  <div id="racer">
    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>
    <div id="meritko">1</div>
    <canvas id="c2"> </canvas>
  </div>



<script src="http://1gr.cz/js/uni/uni.js?rr={rndJS}"></script>
  <script src="stats.js"></script>
  <script src="common.js"></script>
  <script src="myDev.js"></script>

  <script>



  /******////
  //   1 kadr = step     =  16 ms =  0.016 sek
  //   



    /*  Grlobal promeny  */
    /*  common.JS :  Dom ,  Util  , Game  ,  Render  ,  KEY  , COLORS   ,  BACKGROUND   , SPRITES  */

    /*var*/ fps           = 60;                      // how many 'update' frames per second
    /*var*/ step          = 1/fps;                   // how long is each frame (in seconds)
    /*var*/ segments      = [];                      // array of road segments
    /*var*/ stats         = Game.stats('fps');       // mr.doobs FPS counter
    /*var*/ canvas        = element('canvas');       // our canvas...
    /*var*/ ctx           = canvas.getContext('2d');
    /*var*/ width         = 1024;                    // logical canvas width
    /*var*/ height        = 768;                     // logical canvas height
            canvas.width  = width
            canvas.height = height

            c2        = element('c2');       // our canvas...
    /*var*/ ctx2           = c2.getContext('2d');
            c2.width  = width
            c2.height = height


     // ...and its drawing context
    /*var*/ background    = null;                    // our background image (loaded below)
    /*var*/ sprites       = null;                    // our spritesheet (loaded below)
    /*var*/ resolution    = null;                    // scaling factor to provide resolution independence (computed)  // коэффициент масштабирования для предоставления разрешения независимости (вычисленоe    )
            resolution    = height/480;
    /*var*/ roadWidth     = 2000;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
                                                 //  фактически половина дороги шириной, легкое математика, если дорога простирается от -roadWidth до + roadWidth
    /*var*/ segmentLength = 200;                     // length of a single segment
    /*var*/ rumbleLength  = 3;                       // number of segments per red/white rumble strip // strip = полосa
    /*var*/ trackLength   = null;                    // z length of entire track (computed) track = trassa
    /*var*/ lanes         = 5;                       // number of lanes
    /*var*/ fieldOfView   = 75;                     // angle (degrees) for field of view
    /*var*/ cameraHeight  = 400;                    // z height of camera.;from screen (computed)
             cameraDepth  = 1 / Math.tan((fieldOfView/2) * Math.PI/180);
    /*var*/ drawDistance  = 250;                     // number of segments to draw
    /*var*/ playerX       = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
                                                 //игрок Х смещение от центра дороги (от -1 до 1бы расположиться независимым от roadWidth)
    /*var*/ playerZ       = null;                    // player relative z distance from camera (computed)
            playerZ       = (cameraHeight * cameraDepth);



                                                 //игрок относительно z расстояния от камеры
    /*var*/ fogDensity    = 20;                       // exponential fog density
    /*var*/ position      = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
    /*var*/ speed         = 100;                       // current speed
    /*var*/ maxSpeed      =  segmentLength/step ;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)        = 12500
                                                  /* гарантируйте, что мы не можем двигаться более чем на 1 сегмент в одном кадре, чтобы сделать обнаружение коллизий легкое) */
    /*var*/ accel         =  maxSpeed/5;             // acceleration rate - tuned until it 'felt' right ..Темп ускорения - настроен, пока "не чувствовал" право
    /*var*/ breaking      = -maxSpeed;               // deceleration rate when braking   // замедление скорости при торможении
    /*var*/ decel         = -maxSpeed/5;             // 'natural' deceleration rate when neither accelerating, nor braking  //«Естественной» скорость замедления, когда ни ускорения, ни торможения
    /*var*/ offRoadDecel  = -maxSpeed/2;             // off road deceleration is somewhere in between   //бездорожье замедления где-то посередине
    /*var*/ offRoadLimit  =  maxSpeed/4;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)
                                                 //Ограничение при бездорожье

    /*var*/ keyLeft       = false;
    /*var*/ keyRight      = false;
    /*var*/ keyFaster     = false;
    /*var*/ keySlower     = false;
            
            resetRoad();
    //=========================================================================
    // UPDATE THE GAME WORLD
    //=========================================================================

    function update(dt) {

      position = Util.increase(position, dt * speed, trackLength);
      /*dev*/ myspan1.innerHTML = 'position:<b>' + position.toFixed(1) +  '<b>';
      myspan2.innerHTML = 'speed = ' + speed;
      var dx = dt * 2 * (speed/maxSpeed); // at top speed, should be able to cross from left to right (-1 to 1) in 1 second

      if (keyLeft)
        playerX = playerX - dx;
      else if (keyRight)
        playerX = playerX + dx;

      if (keyFaster)
        speed = Util.accelerate(speed, accel, dt);
      else if (keySlower)
        speed = Util.accelerate(speed, breaking, dt);
      else
        speed = Util.accelerate(speed, /*decel*/ 0, dt);

      if (((playerX < -1) || (playerX > 1)) && (speed > offRoadLimit))
        speed = Util.accelerate(speed, offRoadDecel, dt);

      playerX = Util.limit(playerX, -2, 2);     // dont ever let player go too far out of bounds
      speed   = Util.limit(speed, 0, maxSpeed); // or exceed maxSpeed

    }

    //=========================================================================
    // RENDER THE GAME WORLD
    //=========================================================================

    function render() {

      var baseSegment = findSegment(position);
      var maxy        = height;

      ctx.clearRect(0, 0, width, height);

      Render.background(ctx, background, width, height, BACKGROUND.SKY);
      Render.background(ctx, background, width, height, BACKGROUND.HILLS);
      Render.background(ctx, background, width, height, BACKGROUND.TREES);

      var n, segment;

      for(n = 0 ; n < drawDistance ; n++) {
        //console.clear()

        segment        = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n/drawDistance, fogDensity);

        Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        // if (maxy  < 400) debugger
        if ((segment.p1.camera.z <= cameraDepth) || // behind us
            (segment.p2.screen.y >= maxy))          // clip by (already rendered) segment
          continue;


/*console.log( width, lanes, '\n',
                       segment.p1.screen.x,
                       segment.p1.screen.y,
                       segment.p1.screen.w, '\n',
                       segment.p2.screen.x,
                       segment.p2.screen.y,
                       segment.p2.screen.w,'\n',
                       segment.fog,
                       segment.color);*/


        Render.segment(ctx, width, lanes,
                       segment.p1.screen.x,
                       segment.p1.screen.y,
                       segment.p1.screen.w,
                       segment.p2.screen.x,
                       segment.p2.screen.y,
                       segment.p2.screen.w,
                       segment.fog,
                       segment.color);

        maxy = segment.p2.screen.y;
      }

/*      Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,
                    cameraDepth/playerZ,
                    width/2,
                    height,
                    speed * (keyLeft ? -1 : keyRight ? 1 : 0),
                    0);
*/
    }
  
    //=========================================================================
    // BUILD ROAD GEOMETRY
    //=========================================================================

    function resetRoad() {
      segments = [];
      // чтоб не было стробного эффекта ..........
      for(var n = 0 ; n < 500 ; n++) {
        segments.push({
           index: n,
           p1: { world: { z:  n   *segmentLength }, camera: {}, screen: {} },
           p2: { world: { z: (n+1)*segmentLength }, camera: {}, screen: {} },
           color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
        });
      }
          segments[findSegment(playerZ).index + 20].color = COLORS.START;
/*
      segments[findSegment(playerZ).index + 2].color = COLORS.START;
      segments[findSegment(playerZ).index + 3].color = COLORS.START;
      for(var n = 0 ; n < rumbleLength ; n++)
        segments[segments.length-1-n].color = COLORS.FINISH;
*/ 
     trackLength = segments.length * segmentLength;
    }

    function findSegment(z) {
      return segments[Math.floor(z/segmentLength) % segments.length];
    }

    //=========================================================================
    // THE GAME LOOP
    //=========================================================================
    run_attr = {canvas: canvas, render: render, update: update, stats: stats, step: step}

    Game.run({
      canvas: canvas, render: render, update: update, stats: stats, step: step,
      images: ["background", "sprites"],
      images: ["background"],
      keys: [
        { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { keySlower = false; } }
      ],
      ready: function(images) {
        background = images[0];
        // sprites    = images[1];
        // reset();
      }
    });
/*
    function reset(options) {
      console.info('reset');
      options       = options || {};
      canvas.width  = width  = Util.toInt(options.width,          width);
      canvas.height = height = Util.toInt(options.height,         height);
      lanes                  = Util.toInt(options.lanes,          lanes);
      roadWidth              = Util.toInt(options.roadWidth,      roadWidth);
      cameraHeight           = Util.toInt(options.cameraHeight,   cameraHeight);
      drawDistance           = Util.toInt(options.drawDistance,   drawDistance);
      fogDensity             = Util.toInt(options.fogDensity,     fogDensity);
      fieldOfView            = Util.toInt(options.fieldOfView,    fieldOfView);
      segmentLength          = Util.toInt(options.segmentLength,  segmentLength);
      rumbleLength           = Util.toInt(options.rumbleLength,   rumbleLength);
      cameraDepth            = 1 / Math.tan((fieldOfView/2) * Math.PI/180);
      playerZ                = (cameraHeight * cameraDepth);
      resolution             = height/480;
 

      if ((segments.length==0) || (options.segmentLength) || (options.rumbleLength))
        resetRoad(); // only rebuild road when necessary    ///только восстановление дорогив случае необходимости
    }*/

    
  </script>

</body> 

